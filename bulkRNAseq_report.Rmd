---
title: "Report:Transcriptomic effect of Glucose vs Galactose in PDAC"
author: "Andr√©s Gordo Ortiz"
date: "`r Sys.Date()`"
output:
  pdf_document:
    fig_caption: yes
    toc: yes
  html_document:
    code_folding: show
    df_print: paged
    theme: yeti
    highlight: tango
    toc: yes
    toc_float:
      collapsed: false
      smooth_scroll: false
    number_sections: true
---

```{r setup, include=FALSE}
library(rmarkdown)
library(tinytex)
library(knitr)
library(beepr)
library(tidyverse) 
library(tximport)
library(ensembldb) 
library(EnsDb.Hsapiens.v86)
library(edgeR)
library(matrixStats)
library(cowplot)
library(svglite)
library(DT)
library(gt)
library(plotly)
library(limma)
library(gplots)
library(RColorBrewer) 
knitr::opts_chunk$set(echo=FALSE, warning=FALSE, message=FALSE)
```

```{r parametres}
nocpm_threshold<-9 #IMPORTANT PARAMETRE: minimum number of samples with CPM > 1
```



## Protocol

#### 1. Data Acquisition

- Raw sequencing reads for the project (PRJEB10204) were obtained from the [ENA](https://www.ebi.ac.uk/ena/browser/view/PRJEB10204).

#### 2. Read Mapping

- The obtained raw reads were mapped to the human reference transcriptome [GRCh38.cdna](https://ftp.ensembl.org/pub/release-111/fasta/homo_sapiens/cdna/Homo_sapiens.GRCh38.cdna.all.fa.gz) using [Kallisto](https://pachterlab.github.io/kallisto/) version 0.48.
  - Parameters used for Kallisto:
    - Average length of reads: 250
    - Standard deviation: 30

#### 3. Quality Analysis

- The quality of the mapped reads was assessed using [fastqc](https://www.bioinformatics.babraham.ac.uk/projects/fastqc/) and [multiqc](https://multiqc.info/).

#### 4. Experimental Design

- The project includes a total of 20 single-end samples, comprising 10 replicates for each of the two experimental conditions: **with adherent media** and **with sphere media**.

#### 5. Pre-processing

- For each sample, *fastqc* was executed to evaluate the sequencing quality before further analysis.

#### 6. Pseudo-alignment and Automated Script

- Pseudo-alignment of the samples to the human reference genome was performed using Kallisto. While a suitable code is provided for the alignment process, a custom, fully automated script [Automatic Kallisto Gene aligner](https://github.com/AndresBioMed/Glu_vs_Gal_PDAC_RNAseq/blob/main/AutomatedKallistoGeneAlignment.sh) was developed *ad hoc* for streamlined analysis. The script requires the input of *.fastqc.gz* files and a cDNA [reference genome](https://www.ensembl.org/info/data/ftp/index.html).

#### 7. Data Integration

- Following read mapping with Kallisto, the [TxImport](https://bioconductor.org/packages/release/bioc/html/tximport.html) package was utilized to import Kallisto outputs into the R environment.

#### 8. Data Summarization

- Annotation data from Biomart was employed to summarize the data from transcript-level to gene-level, providing a comprehensive view of the gene expression landscape.

```{r studydesign, echo=FALSE}
design<-data.frame(sample=c("ERR978118","ERR978120","ERR978121","ERR978193","ERR978107","ERR978112","ERR978114","ERR978184","ERR978185","ERR978186","ERR978187","ERR978191","ERR978194","ERR978116","ERR978117","ERR978119","ERR978122","ERR978189","ERR978195","ERR978196"),
                   media=c("adh","adh","adh","sph","adh","adh","adh","sph","sph","sph","sph","sph","sph","adh","adh","adh","adh","sph","sph","sph"),
                   replicate=c("b","b","b","b","a","a","a","a","a","a","a","b","b","b","b","b","b","a","b","b"))
#Write design into a .txt file called studydesign
write.table(design, file = "studydesign.txt", sep = "\t", row.names = FALSE)
```

```{r step 1 all samples - TxImport, echo=FALSE}
targets <- read_tsv("studydesign.txt")
samples_nodepth<-targets$sample %in% c("ERR978114","ERR978122","ERR978189","ERR978196") # remove samples without enough read depth, according to fastqc.

path <- file.path(targets$sample, "abundance.tsv") # set file paths to your mapped data
Tx <- transcripts(EnsDb.Hsapiens.v86, columns=c("tx_id", "gene_name"))
Tx <- as_tibble(Tx)
Tx <- dplyr::rename(Tx, target_id = tx_id)
Tx <- dplyr::select(Tx, "target_id", "gene_name")
Txi_gene <- tximport(paste0("kallisto/",path), 
                     type = "kallisto", 
                     tx2gene = Tx, 
                     txOut = FALSE, #Transcripts will be collapsed to genes
                     countsFromAbundance = "lengthScaledTPM",
                     ignoreTxVersion = TRUE)
```

------------------------------------------------------------------------

## Preprocessing

### Filtering & normalisation

```{r step2 - dataWrangling}
sampleLabels <- targets$sample
myDGEList <- DGEList(Txi_gene$counts)
log2.cpm <- cpm(myDGEList, log=TRUE)

log2.cpm.df <- as_tibble(log2.cpm, rownames = "geneID")
colnames(log2.cpm.df) <- c("geneID", sampleLabels)
log2.cpm.df.pivot <- pivot_longer(log2.cpm.df, 
                                  cols = ERR978118:ERR978195,         
                                  names_to = "samples", 
                                  values_to = "expression") 
p1 <- ggplot(log2.cpm.df.pivot) +
  aes(x=samples, y=expression, fill=samples) +
  geom_violin(trim = FALSE, show.legend = FALSE) +
  stat_summary(fun = "median", 
               geom = "point", 
               shape = 95, 
               size = 10, 
               color = "black", 
               show.legend = FALSE) +
  labs(y="log2 expression", x = "Sample",
       title="Log2 Counts per Million (CPM)",
       subtitle="unfiltered, non-normalized",
       caption=paste0("produced on ", Sys.time())) +
  theme_bw()

cpm <- cpm(myDGEList)
keepers <- rowSums(cpm>1)>=nocpm_threshold 
myDGEList.filtered <- myDGEList[keepers,]

log2.cpm.filtered <- cpm(myDGEList.filtered, log=TRUE)
log2.cpm.filtered.df <- as_tibble(log2.cpm.filtered, rownames = "geneID")
colnames(log2.cpm.filtered.df) <- c("geneID", sampleLabels)
log2.cpm.filtered.df.pivot <- pivot_longer(log2.cpm.filtered.df, 
                                           cols = ERR978118:ERR978195, 
                                           names_to = "samples", 
                                           values_to = "expression") 

p2 <- ggplot(log2.cpm.filtered.df.pivot) +
  aes(x=samples, y=expression, fill=samples) +
  geom_violin(trim = FALSE, show.legend = FALSE) +
  stat_summary(fun = "median", 
               geom = "point", 
               shape = 95, 
               size = 10, 
               color = "black", 
               show.legend = FALSE) +
  labs(y="log2 expression", x = "Sample",
       title="Log2 Counts per Million (CPM)",
       subtitle="filtered, non-normalised",
       caption=paste0("produced on ", Sys.time())) +
  theme_bw()

myDGEList.filtered.norm <- calcNormFactors(myDGEList.filtered, method = "TMM")
log2.cpm.filtered.norm <- cpm(myDGEList.filtered.norm, log=TRUE)
log2.cpm.filtered.norm.df <- as_tibble(log2.cpm.filtered.norm, rownames = "geneID")
colnames(log2.cpm.filtered.norm.df) <- c("geneID", sampleLabels)
log2.cpm.filtered.norm.df.pivot <- pivot_longer(log2.cpm.filtered.norm.df, 
                                                cols = ERR978118:ERR978195,
                                                names_to = "samples", 
                                                values_to = "expression") 

p3 <- ggplot(log2.cpm.filtered.norm.df.pivot) +
  aes(x=samples, y=expression, fill=samples) +
  geom_violin(trim = FALSE, show.legend = FALSE) +
  stat_summary(fun = "median", 
               geom = "point", 
               shape = 95, 
               size = 10, 
               color = "black", 
               show.legend = FALSE) +
  labs(y="log2 expression", x = "Sample",
       title="Log2 Counts per Million (CPM)",
       subtitle="filtered, TMM normalised",
       caption=paste0("produced on ", Sys.time())) +
  theme_bw()

#Create the directories for output results
dir.create("report/data", showWarnings = FALSE, recursive = TRUE)
write.csv(log2.cpm.filtered.norm.df, "report/data/log2_cpm_filtered_norm.csv", row.names = F)
write.csv(log2.cpm.filtered.df, "report/data/log2_cpm_filtered.csv", row.names = F)
```

```{r step 1 & 2 filtered out samples}
targets<-targets[!samples_nodepth,]
path <- file.path(targets$sample, "abundance.tsv") # set file paths to your mapped data
Tx <- transcripts(EnsDb.Hsapiens.v86, columns=c("tx_id", "gene_name"))
Tx <- as_tibble(Tx)
Tx <- dplyr::rename(Tx, target_id = tx_id)
Tx <- dplyr::select(Tx, "target_id", "gene_name")
Txi_gene <- tximport(paste0("kallisto/",path), 
                     type = "kallisto", 
                     tx2gene = Tx, 
                     txOut = FALSE, #Transcripts will be collapsed to genes
                     countsFromAbundance = "lengthScaledTPM",
                     ignoreTxVersion = TRUE)

sampleLabels <- targets$sample
myDGEList <- DGEList(Txi_gene$counts)
log2.cpm <- cpm(myDGEList, log=TRUE)

log2.cpm.df <- as_tibble(log2.cpm, rownames = "geneID")
colnames(log2.cpm.df) <- c("geneID", sampleLabels)
log2.cpm.df.pivot <- pivot_longer(log2.cpm.df, 
                                  cols = ERR978118:ERR978195,         
                                  names_to = "samples", 
                                  values_to = "expression") 

cpm <- cpm(myDGEList)
keepers <- rowSums(cpm>1)>=nocpm_threshold 
myDGEList.filtered <- myDGEList[keepers,]

log2.cpm.filtered <- cpm(myDGEList.filtered, log=TRUE)
log2.cpm.filtered.df <- as_tibble(log2.cpm.filtered, rownames = "geneID")
colnames(log2.cpm.filtered.df) <- c("geneID", sampleLabels)
log2.cpm.filtered.df.pivot <- pivot_longer(log2.cpm.filtered.df, 
                                           cols = ERR978118:ERR978195, 
                                           names_to = "samples", 
                                           values_to = "expression") 


myDGEList.filtered.norm <- calcNormFactors(myDGEList.filtered, method = "TMM")
log2.cpm.filtered.norm <- cpm(myDGEList.filtered.norm, log=TRUE)
log2.cpm.filtered.norm.df <- as_tibble(log2.cpm.filtered.norm, rownames = "geneID")
colnames(log2.cpm.filtered.norm.df) <- c("geneID", sampleLabels)
log2.cpm.filtered.norm.df.pivot <- pivot_longer(log2.cpm.filtered.norm.df, 
                                                cols = ERR978118:ERR978195,
                                                names_to = "samples", 
                                                values_to = "expression") 

p4 <- ggplot(log2.cpm.filtered.norm.df.pivot) +
  aes(x=samples, y=expression, fill=samples) +
  geom_violin(trim = FALSE, show.legend = FALSE) +
  stat_summary(fun = "median", 
               geom = "point", 
               shape = 95, 
               size = 10, 
               color = "black", 
               show.legend = FALSE) +
  labs(y="log2 expression", x = "Sample",
       title="Log2 Counts per Million (CPM)",
       subtitle="filtered, TMM normalised, fastQC passed",
       caption=paste0("produced on ", Sys.time())) +
  theme_bw()
pt<-plot_grid(p1, p2, p3, p4,  labels = c('A', 'B', 'C', "D"), label_size = 12, align="hv")

#Create folder for plots
dir.create("report/plots", showWarnings = FALSE, recursive = TRUE)
save_plot("report/plots/log2_cpm_nonfilt_nonnorm.svg",p1, base_width = 15, base_height = 7)
save_plot("report/plots/log2_cpm_nonfilt_nonnorm.png",p1, base_width = 15, base_height = 7)
save_plot("report/plots/log2_cpm_filt_nonnorm.svg",p2, base_width = 15, base_height = 7)
save_plot("report/plots/log2_cpm_filt_nonnorm.png",p2, base_width = 15, base_height = 7)
save_plot("report/plots/log2_cpm_filt_norm.svg",p3, base_width = 15, base_height = 7)
save_plot("report/plots/log2_cpm_filt_norm.png",p3, base_width = 15, base_height = 7)
save_plot("report/plots/log2_cpm_filt_norm_fastqc_ok.svg",p4, base_width = 15, base_height = 7)
save_plot("report/plots/log2_cpm_filt_norm_fastqc_ok.png",p4, base_width = 15, base_height = 7)
save_plot("report/plots/allqualityplots.svg",pt, base_width = 30, base_height = 10)
save_plot("report/plots/allqualityplots.png",pt, base_width = 30, base_height = 10)

pt
```

Filtering was carried out to remove lowly expressed genes. Genes with less than 1 count per million (CPM) in at least `r nocpm_threshold` or more samples were filtered out. This is done to make sure that the low expression is due to a lack of significance across **all** conditions, and not an intrinsic propoerty of one of them. This filtering reduced the number of genes from `r nrow(myDGEList)` to `r nrow(myDGEList.filtered)`. Normalisation of samples was performed with [edgeR](https://bioconductor.org/packages/release/bioc/html/edgeR.html), using *Trimmed Mean of M-value* or *TMM*. This method is based on the assumption that most genes are not differentially expressed. It **calculates a scaling factor for each sample**, which is the median of the ratio of each gene's expression to the geometric mean of all samples. This scaling factor is then used to normalise the expression of each gene in each sample. The normalised expression is then expressed as log2(CPM). The normalisation step is important because it **allows for the comparison of expression between samples**.

According to *fastqc* results, a total of `r sum(samples_nodepth)` samples were removed due to low quality. This is `r round(sum(samples_nodepth)/length(samples_nodepth)*100, 2)`% of the total reads. Filtered out samples are: `r targets$sample[samples_nodepth]`.


------------------------------------------------------------------------

### Filtered and Normalised data

```{r step 3 - multivariate part 1 (data table)}
mydata.df <- mutate(log2.cpm.filtered.norm.df,
                    adh.AVG = (ERR978118+ERR978120+ERR978121+ERR978107+ERR978112+ERR978116+ERR978117+ERR978119
)/8, 
                    sph.AVG = (ERR978193+ERR978184+ERR978185+ERR978186+ERR978187+ERR978191+ERR978194+ERR978195
)/8,
                    
                    LogFC = (sph.AVG - adh.AVG)) %>% 
  mutate_if(is.numeric, round, 2)
dir.create("report/tables", showWarnings = FALSE, recursive = TRUE)

write.csv(mydata.df, "report/tables/table_1_filtered_normalised.csv", row.names = FALSE)

scatter <- ggplot(mydata.df) + 
  aes(x=adh.AVG, y=sph.AVG, color=abs(LogFC)) +
  geom_point(shape=16, size=1) +
  ggtitle("sph vs. adh") +
  theme_bw()
save_plot("report/plots/scatter.svg",scatter, base_width = 10, base_height = 10)
save_plot("report/plots/scatter.png",scatter, base_width = 10, base_height = 10)
# only in html ggplotly(scatter)
scatter
```

```{r datable -only in html, eval=FALSE}
datatable(mydata.df[,c(1,(ncol(mydata.df)-2):ncol(mydata.df))],
          caption = 'Table 1: Filtered and Normalised Genes',
          extensions = c('KeyTable', "FixedHeader"), 
          filter = 'top',
          options = list(keys = TRUE, 
                         searchHighlight = TRUE, 
                         pageLength = 10, 
                         lengthMenu = c("10", "25", "50", "100")))

```

The **Table 1** includes expression data for `r nrow(myDGEList.filtered)` genes. You can sort and search the data directly from the table in the *html* file.

------------------------------------------------------------------------

## PCA plot

```{r step 3 - multivariate part 2 (PCA plot), warning=FALSE, message=FALSE}
media <- targets$media
media <- factor(media)
rep <- targets$replicate
rep <- factor(rep)

pca.res <- prcomp(t(log2.cpm.filtered.norm), scale.=F, retx=T)
pc.var<-pca.res$sdev^2 # sdev^2 captures these eigenvalues from the PCA result
pc.per<-round(pc.var/sum(pc.var)*100, 1) 
pca.res.df <- pca.res$x[,1:4] %>% 
  as_tibble() %>%
  add_column(sample = sampleLabels,
             group = media)

pca.plot_media <- ggplot(pca.res.df) +
  aes(x=PC1, y=PC2, label=sampleLabels, color = media) +
  geom_point(size=4) +
  stat_ellipse() +
  xlab(paste0("PC1 (",pc.per[1],"%",")")) + 
  ylab(paste0("PC2 (",pc.per[2],"%",")")) +
  labs(title="PCA plot coloured by Media",
       caption=paste0("produced on ", Sys.time())) +
  coord_fixed() +
  theme_bw()

pca.plot_replicate <- ggplot(pca.res.df) +
  aes(x=PC1, y=PC2, label=sampleLabels, color = rep) +
  geom_point(size=4) +
  stat_ellipse() +
  xlab(paste0("PC1 (",pc.per[1],"%",")")) + 
  ylab(paste0("PC2 (",pc.per[2],"%",")")) +
  labs(title="PCA plot coloured by replicate",
       caption=paste0("produced on ", Sys.time())) +
  coord_fixed() +
  theme_bw()
# For html ggplotly(pca.plot_media)

  
pca.pivot <- pivot_longer(pca.res.df, 
                          cols = PC1:PC4, 
                          names_to = "PC", 
                          values_to = "loadings") 

small_multiples_plot<-ggplot(pca.pivot) +
  aes(x=sample, y=loadings, fill=sample) + 
  geom_bar(stat="identity") +
  facet_wrap(~PC) +
  labs(title="PCA 'small multiples' plot",
       caption=paste0("produced on ", Sys.time())) +
  theme_bw() +
  theme(legend.position = "none") +
  coord_flip()

all_pca<-plot_grid(pca.plot_media,small_multiples_plot,labels = c('A', 'B'), label_size = 12)
save_plot("report/plots/pca.svg",pca.plot_media, base_width = 15, base_height = 7)
save_plot("report/plots/pca.png",pca.plot_media, base_width = 15, base_height = 7)
save_plot("report/plots/pca_sm.svg",small_multiples_plot, base_width = 15, base_height = 7)
save_plot("report/plots/pca_sm.png",small_multiples_plot, base_width = 15, base_height = 7)
save_plot("report/plots/all_pca.svg",all_pca, base_width = 15, base_height = 7)
save_plot("report/plots/all_pca.png",all_pca, base_width = 15, base_height = 7)

all_pca
```

------------------------------------------------------------------------

## Volcano plot

```{r step 5 - diffGenes part 1 (volcano plot), warning=FALSE}
design <- model.matrix(~0 + media)
colnames(design) <- levels(media)

v.DEGList.filtered.norm <- voom(myDGEList.filtered.norm, design, plot = FALSE)
fit <- lmFit(v.DEGList.filtered.norm, design)
contrast.matrix <- makeContrasts(treatment = sph - adh,
                                 levels=design)

fits <- contrasts.fit(fit, contrast.matrix)
ebFit <- eBayes(fits)
myTopHits <- topTable(ebFit, adjust ="BH", coef=1, number=40000, sort.by="logFC")

myTopHits.df <- myTopHits %>%
  as_tibble(rownames = "geneID")
write.csv(myTopHits.df, "report/tables/statistics_results.csv", row.names = FALSE)

vplot <- ggplot(myTopHits.df) +
  aes(y=-log10(adj.P.Val), x=logFC, text = paste("Symbol:", geneID)) +
  geom_point(size=2) +
  geom_hline(yintercept = -log10(0.01), linetype="longdash", colour="grey", size=1) +
  geom_vline(xintercept = 2, linetype="longdash", colour="#BE684D", size=1) +
  geom_vline(xintercept = -2, linetype="longdash", colour="#2C467A", size=1) +
  #annotate("rect", xmin = 1, xmax = 12, ymin = -log10(0.01), ymax = 7.5, alpha=.2, fill="#BE684D") +
  #annotate("rect", xmin = -1, xmax = -12, ymin = -log10(0.01), ymax = 7.5, alpha=.2, fill="#2C467A") +
  labs(title="Volcano plot",
       subtitle = "Cancer Stem Cells enriched Genes",
       caption=paste0("produced on ", Sys.time())) +
  scale_x_continuous(n.breaks = 8)+
  theme_bw()

save_plot("report/plots/volcano.svg",vplot, base_width = 15, base_height = 7)
save_plot("report/plots/volcano.png",vplot, base_width = 15, base_height = 7)
# Only in html ggplotly(vplot)
vplot


```

------------------------------------------------------------------------

## Table of DEGs

To identify differentially expressed genes, precision weights were first applied to each gene based on its mean-variance relationship using [VOOM](https://genomebiology.biomedcentral.com/articles/10.1186/gb-2014-15-2-r29), then data was normalized using the [TMM method](https://genomebiology.biomedcentral.com/articles/10.1186/gb-2010-11-3-r25) in [EdgeR](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2796818/). Linear modeling and bayesian stats were employed via [Limma](https://academic.oup.com/nar/article/43/7/e47/2414268) to find genes that were up- or down-regulated by **2-fold or more, with a false-discovery rate (FDR) of 0.01**.

```{r step 5 - diffGenes part 2 (DEG table)}
results <- decideTests(ebFit, method="global", adjust.method="BH", p.value=0.01, lfc=2)
colnames(v.DEGList.filtered.norm$E) <- sampleLabels
diffGenes <- v.DEGList.filtered.norm$E[results[,1] !=0,]
diffGenes.df <- as_tibble(diffGenes, rownames = "geneID")

write.csv(diffGenes.df, "report/tables/table_2_diffGenes.csv", row.names = FALSE)
```

```{r table 2 only html, eval=FALSE}
datatable(diffGenes.df, 
          extensions = c('KeyTable', "FixedHeader"), 
          caption = 'Table 2: DEGs after Cancer Stem Cells Enrichment',
          options = list(keys = TRUE, searchHighlight = TRUE, pageLength = 10, lengthMenu = c("10", "25", "50", "100"))) %>%
  formatRound(columns=c(2:17), digits=2)
```

------------------------------------------------------------------------

## Isoform Switch Analyzer

Transcript isoforms expression and usage change was analysed through the well-established [IsoformSwitchAnalyzeR](https://bioconductor.org/packages/release/bioc/vignettes/IsoformSwitchAnalyzeR/inst/doc/IsoformSwitchAnalyzeR.html).
All credits to:
*Soneson et al. Differential analyses for RNA-seq: transcript-level estimates improve gene-level inferences. F1000Research 4, 1521 (2015).*

```{r Isoform Switch Analyzer,results='hide', message=FALSE, warning=FALSE}
library(IsoformSwitchAnalyzeR)

targets.mod <- targets %>%
  dplyr::rename(sampleID = sample, condition = media) %>%
  dplyr::select(sampleID, condition)

Txi_trans <- importIsoformExpression(sampleVector = paste0("kallisto/",path))
colnames(Txi_trans$abundance) <- c("isoform_id", sampleLabels)
colnames(Txi_trans$counts) <- c("isoform_id", sampleLabels)

# Define file paths
gtf_file_path <- "Homo_sapiens.GRCh38.110.chr_patch_hapl_scaff.gtf.gz"
fa_file_path <- "Homo_sapiens.GRCh38.cdna.all.fa.gz"

# Check if files exist
if (!file.exists(gtf_file_path)) {
  download.file("https://ftp.ensembl.org/pub/release-111/gtf/homo_sapiens/Homo_sapiens.GRCh38.111.chr_patch_hapl_scaff.gtf.gz", gtf_file_path)
}

if (!file.exists(fa_file_path)) {
  download.file("https://ftp.ensembl.org/pub/release-111/fasta/homo_sapiens/cdna/Homo_sapiens.GRCh38.cdna.all.fa.gz", fa_file_path)
}


mySwitchList <- importRdata(
  isoformCountMatrix   = Txi_trans$counts,
  isoformRepExpression = Txi_trans$abundance,
  designMatrix         = targets.mod,
  removeNonConvensionalChr = TRUE,
  addAnnotatedORFs=TRUE,
  fixStringTieAnnotationProblem = TRUE,
  ignoreAfterPeriod=TRUE,
  # the files below must be from the same ensembl release, and must match the reference release version that were originally mapped to the reads.
  isoformExonAnnoation = "Homo_sapiens.GRCh38.110.chr_patch_hapl_scaff.gtf.gz",
  isoformNtFasta       = "Homo_sapiens.GRCh38.cdna.all.fa.gz",
  showProgress = TRUE)

dir.create("report/isoformSwitch")

mySwitchList <- isoformSwitchAnalysisCombined(
  switchAnalyzeRlist   = mySwitchList,
  pathToOutput = 'report/isoformSwitch')

top_switches<-extractTopSwitches(
  mySwitchList,
  filterForConsequences = TRUE, 
  sortByQvals = TRUE)

```
```{r summary of Isoform Switch}
extractSwitchSummary(mySwitchList)

```

```{r table 4 Isoform Switches only html, eval=FALSE}


datatable(top_switches[,-1],
          caption = 'Table 4: Top Isoform Switches',
          extensions = c('KeyTable', "FixedHeader"), 
          filter = 'top',
          options = list(keys = TRUE, 
                         searchHighlight = TRUE, 
                         pageLength = 10, 
                         lengthMenu = c("10", "25", "50", "100")))
```

```{r example switchplot}
switchPlot(
  mySwitchList,
  gene=top_switches$gene_id[1],
  condition1 = 'adh',
  condition2 = 'sph',
  localTheme = theme_bw())
```



```{r IsoformSwitch w/ structure analysis, eval=FALSE}
mySwitchList2 <- importRdata(
  isoformCountMatrix   = Txi_trans$counts,
  isoformRepExpression = Txi_trans$abundance,
  designMatrix         = targets.mod,
  removeNonConvensionalChr = TRUE,
  addAnnotatedORFs=TRUE,
  fixStringTieAnnotationProblem = TRUE,
  ignoreAfterPeriod=TRUE,
  # the files below must be from the same ensembl release, and must match the reference release version that were originally mapped to the reads.
  isoformExonAnnoation = "Homo_sapiens.GRCh38.110.chr_patch_hapl_scaff.gtf.gz",
  isoformNtFasta       = "Homo_sapiens.GRCh38.cdna.all.fa.gz",
  showProgress = TRUE)
dir.create("report/IsoformSwitchAnalyzer")
mySwitchList2 <- isoformSwitchAnalysisPart1(
    switchAnalyzeRlist   = mySwitchList2,
    pathToOutput = 'report/IsoformSwitchAnalyzer',
    outputSequences      = TRUE, # change to TRUE when analyzing your own data 
    prepareForWebServers = TRUE  # change to TRUE if you will use webservers for external sequence analysis
)

mySwitchList2 <- isoformSwitchAnalysisPart2(
  switchAnalyzeRlist        = mySwitchList2, 
  n                         = 15,    # if plotting was enabled, it would only output the top 10 switches
  removeNoncodinORFs        = TRUE,
  pathToCPC2resultFile      = "report/IsoformSwitchAnalyzer/extdata/result_cpc2.txt", #http://cpc2.gao-lab.org/
  pathToPFAMresultFile      = "report/IsoformSwitchAnalyzer/extdata/interpro_results.txt", #https://www.ebi.ac.uk/interpro
  #pathToIUPred2AresultFile  = system.file("extdata/iupred2a_result.txt.gz"),
  pathToSignalPresultFile   = "report/IsoformSwitchAnalyzer/extdata/signalP_results.txt",
  outputPlots               = TRUE  
)

```

------------------------------------------------------------------------

## Heatmaps and modules

Pearson correlation was used to cluster **`r nrow(diffGenes)`** differentially expressed genes, which were then represented as heatmap with the data scaled by *Zscore* for each row.

```{r step 6 - modules part 1 (heatmap), results='hide'}
myheatcolors <- rev(brewer.pal(name="RdBu", n=11))
clustRows <- hclust(as.dist(1-cor(t(diffGenes), method="pearson")), method="complete") 

clustColumns <- hclust(as.dist(1-cor(diffGenes, method="spearman")), method="complete")
module.assign <- cutree(clustRows, k=2) #Important parametre
module.color <- rainbow(length(unique(module.assign)), start=0.1, end=0.9) 
module.color <- module.color[as.vector(module.assign)] 

svg(file = "report/plots/heatmap_full.svg")
heatmap.2(diffGenes, 
          Rowv=as.dendrogram(clustRows), 
          Colv=as.dendrogram(clustColumns),
          RowSideColors=module.color,
          col=myheatcolors, scale='row', labRow=NA,
          density.info="none", trace="none",  
          cexRow=1, cexCol=1, margins=c(7,8))
dev.off()

png(file = "report/plots/heatmap_full.png")
heatmap.2(diffGenes, 
          Rowv=as.dendrogram(clustRows), 
          Colv=as.dendrogram(clustColumns),
          RowSideColors=module.color,
          col=myheatcolors, scale='row', labRow=NA,
          density.info="none", trace="none",  
          cexRow=1, cexCol=1, margins=c(7,8))
dev.off()

```
```{r heatmap full pdf version}
heatmap.2(diffGenes, 
          Rowv=as.dendrogram(clustRows), 
          Colv=as.dendrogram(clustColumns),
          RowSideColors=module.color,
          col=myheatcolors, scale='row', labRow=NA,
          density.info="none", trace="none",  
          cexRow=1, cexCol=1, margins=c(7,8))
```



```{r interactive heatmap full onl html, eval=FALSE}

heatmaply(diffGenes, 
          colors = myheatcolors,
          Rowv=as.dendrogram(clustRows),
          RowSideColors=module.color,
          showticklabels=c(TRUE,FALSE),
          scale='row',
          main ="Heatmap across all samples",)

```

```{r step 6 - modules part 2 (cluster upregulated in sph), results='hide'}
modulePick <- 1  #Be careful with which is which
myModule_up <- diffGenes[names(module.assign[module.assign %in% modulePick]),] 
hrsub_up <- hclust(as.dist(1-cor(t(myModule_up), method="pearson")), method="complete") 

svg(file = "report/plots/heatmap_upRegulated.svg")
heatmap.2(myModule_up, 
          Rowv=as.dendrogram(hrsub_up), 
          Colv=as.dendrogram(clustColumns), 
          labRow = NA,
          col=myheatcolors, scale="row", 
          density.info="none", trace="none", 
          RowSideColors=module.color[module.assign%in%modulePick], margins=c(8,20))
dev.off()

png(file = "report/plots/heatmap_upRegulated.png")
heatmap.2(myModule_up, 
          Rowv=as.dendrogram(hrsub_up), 
          Colv=as.dendrogram(clustColumns), 
          labRow = NA,
          col=myheatcolors, scale="row", 
          density.info="none", trace="none", 
          RowSideColors=module.color[module.assign%in%modulePick], margins=c(8,20))
dev.off()

moduleSymbols <- tibble(geneID = rev(hrsub_up$labels[hrsub_up$order]))
moduleData <- diffGenes[moduleSymbols$geneID,]
moduleData.df <- as_tibble(moduleData, rownames = "geneSymbol", .name_repair = "unique")
write_csv(moduleData.df,"report/tables/module_upRegulatedInSph.csv")
```

```{r heatmap up pdf version}
heatmap.2(myModule_up, 
          Rowv=as.dendrogram(hrsub_up), 
          Colv=as.dendrogram(clustColumns), 
          labRow = NA,
          col=myheatcolors, scale="row", 
          density.info="none", trace="none", 
          RowSideColors=module.color[module.assign%in%modulePick], margins=c(8,20))
```



```{r interactive heatmap up only html, eval=FALSE}

heatmaply(myModule_up, 
          colors = myheatcolors,
          Rowv=as.dendrogram(hrsub_up), 
          Colv=as.dendrogram(clustColumns),
          RowSideColors=module.color[module.assign%in%modulePick],
          showticklabels=c(TRUE,FALSE),
          scale='row',
          main ="Heatmap of UpRegulated Genes in Sph")

```

```{r step 6 - modules part 3 (downregulated genes in sph)}
modulePick <- 2 
myModule_down <- diffGenes[names(module.assign[module.assign %in% modulePick]),] 
hrsub_down <- hclust(as.dist(1-cor(t(myModule_down), method="pearson")), method="complete") 

svg(file = "report/plots/heatmap_downRegulated.svg")
heatmap.2(myModule_down, 
          Rowv=as.dendrogram(hrsub_down), 
          Colv=as.dendrogram(clustColumns), 
          labRow = NA,
          col=myheatcolors, scale="row", 
          density.info="none", trace="none", 
          RowSideColors=module.color[module.assign%in%modulePick])
dev.off()

png(file = "report/plots/heatmap_downRegulated.png")
heatmap.2(myModule_down, 
          Rowv=as.dendrogram(hrsub_down), 
          Colv=as.dendrogram(clustColumns), 
          labRow = NA,
          col=myheatcolors, scale="row", 
          density.info="none", trace="none", 
          RowSideColors=module.color[module.assign%in%modulePick])
dev.off()

moduleSymbols <- tibble(geneID = rev(hrsub_down$labels[hrsub_down$order]))
moduleData <- diffGenes[moduleSymbols$geneID,]
moduleData.df <- as_tibble(moduleData, rownames = "geneSymbol", .name_repair = "unique")
write_csv(moduleData.df,"report/tables/module_downRegulatedInSph.csv")
```

```{r heatmap down pdf version}
heatmap.2(myModule_down, 
          Rowv=as.dendrogram(hrsub_down), 
          Colv=as.dendrogram(clustColumns), 
          labRow = NA,
          col=myheatcolors, scale="row", 
          density.info="none", trace="none", 
          RowSideColors=module.color[module.assign%in%modulePick], margins=c(8,20))
```



```{r interactive heatmap down only html, eval=FALSE}

heatmaply(myModule_down, 
          colors = myheatcolors,
          Rowv=as.dendrogram(hrsub_down), 
          Colv=as.dendrogram(clustColumns),
          RowSideColors=module.color[module.assign%in%modulePick],
          showticklabels=c(TRUE,FALSE),
          scale='row',
          main ="Heatmap of DownRegulated Genes in Sph")

```
## GO enrichment

GO enrichment for the `r nrow(myTopHits)` genes induced by infection

```{r step 7 - functionalEnrichment part 1 (gostplot for upregulated genes)}
library(tidyverse)
library(limma)
library(gplots) #for heatmaps
library(DT) #interactive and searchable tables of our GSEA results
library(GSEABase) #functions and methods for Gene Set Enrichment Analysis
library(Biobase) #base functions for bioconductor; required by GSEABase
library(GSVA) #Gene Set Variation Analysis, a non-parametric and unsupervised method for estimating variation of gene set enrichment across samples.
library(gprofiler2) #tools for accessing the GO enrichment results using g:Profiler web resources
library(clusterProfiler) # provides a suite of tools for functional enrichment analysis
library(msigdbr) # access to msigdb collections directly within R
library(enrichplot) # great for making the standard GSEA enrichment plots
gost.res_up <- gost(rownames(myModule_up), organism = "hsapiens", correction_method = "fdr")
gostplot(gost.res_up, interactive = F, capped = F) #set interactive=FALSE to get plot for publications

```

```{r step 7 - functionalEnrichment part 2 (gostplot for downregulated genes)}
gost.res_down <- gost(rownames(myModule_down), organism = "hsapiens", correction_method = "fdr")
gostplot(gost.res_down, interactive = F, capped = T) #set interactive=FALSE to get plot for publications
```

## GSEA

```{r step 7 - functionalEnrichment part 3 (GSEA table)}
hs_gsea_c2 <- msigdbr(species = "Homo sapiens", # change depending on species your data came from
                      category = "C2") %>% # choose your msigdb collection of interest
  dplyr::select(gs_name, gene_symbol) #just get the columns corresponding to signature name and gene symbols of genes in each signature 

# Now that you have your msigdb collections ready, prepare your data
# grab the dataframe you made in step3 script
# Pull out just the columns corresponding to gene symbols and LogFC for at least one pairwise comparison for the enrichment analysis
mydata.df.sub <- dplyr::select(mydata.df, geneID, LogFC)
mydata.gsea <- mydata.df.sub$LogFC
names(mydata.gsea) <- as.character(mydata.df.sub$geneID)
mydata.gsea <- sort(mydata.gsea, decreasing = TRUE)

# run GSEA using the 'GSEA' function from clusterProfiler
myGSEA.res <- GSEA(mydata.gsea, TERM2GENE=hs_gsea_c2, verbose=FALSE)
myGSEA.df <- as_tibble(myGSEA.res@result)
```

```{r table 3 only html, eval=FALSE}
# view results as an interactive table
datatable(myGSEA.df, 
          extensions = c('KeyTable', "FixedHeader"), 
          caption = 'Signatures enriched after Sphere Media',
          options = list(keys = TRUE, searchHighlight = TRUE, pageLength = 10, lengthMenu = c("10", "25", "50", "100"))) %>%
  formatRound(columns=c(3:10), digits=2)

```

```{r step 7 - functionalEnrichment part 4 (enrich plot)}
# create enrichment plots using the enrichplot package
gseaplot2(myGSEA.res, 
          geneSetID = 136, #can choose multiple signatures to overlay in this plot
          pvalue_table = T, #can set this to FALSE for a cleaner plot
          title = myGSEA.res$Description[136]) #can also turn off this title

```

```{r step 7 - functionalEnrichment part 5 (bubble plot)}
# add a variable to this result that matches enrichment direction with phenotype
myGSEA.df <- myGSEA.df %>%
  mutate(phenotype = case_when(
    NES > 0 ~ "sph",
    NES < 0 ~ "adh"))
abs(myGSEA.df$NES)
top <- sort(abs(myGSEA.df$NES), index.return=TRUE, decreasing=TRUE)
# create 'bubble plot' to summarize y signatures across x phenotypes
ggplot(myGSEA.df[top$ix[1:20],], aes(x=phenotype, y=ID)) + 
  geom_point(aes(size=setSize, color = NES, alpha=-log10(p.adjust))) +
  scale_color_gradient(low="blue", high="red") +
  theme_bw()

```

------------------------------------------------------------------------

## Conclusions


## Session info

The output from running 'sessionInfo' is shown below and details all packages and version necessary to reproduce the results in this report.

```{r session info}
sessionInfo()
```

```{r final beep, results='hide'}
beep(3)
