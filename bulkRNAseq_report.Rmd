---
title: "<center> Transcriptomic effect of Glucose vs Galactose in PDAC <center>"
author: "<center> Andr√©s Gordo Ortiz<center><br>"
date: "<center> _`r Sys.Date()`_ <center>"
output:
  html_document:
    code_folding: show
    df_print: paged
    theme: yeti
    highlight: tango
    toc: yes
    toc_float:
      collapsed: false
      smooth_scroll: false
    number_sections: true
  pdf_document:
    fig_caption: yes
    toc: yes
---

```{r setup, include=FALSE}
library(rmarkdown)
library(tinytex)
library(knitr)
knitr::opts_chunk$set(echo=TRUE, warning=FALSE, message=FALSE)
```

```{r parametres}
nocpm_threshold<-9 #IMPORTANT PARAMETRE: minimum number of samples with CPM > 1
```


## Introduction


------------------------------------------------------------------------

## R packages used


------------------------------------------------------------------------

## Read mapping

### Software

Raw reads from [ENA](https://www.ebi.ac.uk/ena/browser/view/PRJEB10204) -- Project: *PRJEB10204* --  were mapped to the human reference transcriptome *GRCh38.cdna* using [Kallisto](https://pachterlab.github.io/kallisto/) The quality of the read were analysed using [fastqc](https://www.bioinformatics.babraham.ac.uk/projects/fastqc/) and [multiqc](https://multiqc.info/).

### Aligning raw reads with Kallisto

In this project there are a total of 6 single-end samples consisting of 3 replicates of 2 conditions; **with adherent media** or **with sphere media**. For each sample *fastqc* was run to determine the quality of the sequencing. Kallisto was then used to pseudo-align the samples to the most updated reference human genome. Although I provide a suitable code for performing the aligning, a fully tailored automatic script [Automatic Kallisto Gene aligner](https://github.com/AndresBioMed/Glu_vs_Gal_PDAC_RNAseq/blob/main/AutomatedKallistoGeneAlignment.sh) was written *ad hoc* in order to facilitate multiple sample analysis. It only needs the *.fastqc.gz* files, and a cDNA [reference genome](https://www.ensembl.org/info/data/ftp/index.html).


------------------------------------------------------------------------

### Importing count data into R

After read mapping with Kallisto, [TxImport](https://bioconductor.org/packages/release/bioc/html/tximport.html) was used to read kallisto outputs into the R environment. Annotation data from Biomart was used to summarize data from transcript-level to gene-level.

```{r studydesign, echo=FALSE}
design<-data.frame(sample=c("ERR978118","ERR978120","ERR978121","ERR978193","ERR978107","ERR978112","ERR978114","ERR978184","ERR978185","ERR978186","ERR978187","ERR978191","ERR978194","ERR978116","ERR978117","ERR978119","ERR978122","ERR978189","ERR978195","ERR978196"),
                   media=c("adh","adh","adh","sph","adh","adh","adh","sph","sph","sph","sph","sph","sph","adh","adh","adh","adh","sph","sph","sph"),
                   replicate=c("b","b","b","b","a","a","a","a","a","a","a","b","b","b","b","b","b","a","b","b"))
#Write design into a .txt file called studydesign
write.table(design, file = "studydesign.txt", sep = "\t", row.names = FALSE)
```

```{r step 1 all samples - TxImport, echo=FALSE}
library(tidyverse) 
library(tximport)
library(ensembldb) 
library(EnsDb.Hsapiens.v86)
targets <- read_tsv("studydesign.txt")
samples_nodepth<-targets$sample %in% c("ERR978114","ERR978122","ERR978189","ERR978196") # remove samples without enough read depth, according to fastqc.

path <- file.path(targets$sample, "abundance.tsv") # set file paths to your mapped data
Tx <- transcripts(EnsDb.Hsapiens.v86, columns=c("tx_id", "gene_name"))
Tx <- as_tibble(Tx)
Tx <- dplyr::rename(Tx, target_id = tx_id)
Tx <- dplyr::select(Tx, "target_id", "gene_name")
Txi_gene <- tximport(paste0("kallisto/",path), 
                     type = "kallisto", 
                     tx2gene = Tx, 
                     txOut = FALSE, #Transcripts will be collapsed to genes
                     countsFromAbundance = "lengthScaledTPM",
                     ignoreTxVersion = TRUE)
```

------------------------------------------------------------------------

## Preprocessing

### Filtering & normalisation

```{r step2 - dataWrangling}
library(edgeR)
library(matrixStats)
library(cowplot)
library(svglite)

sampleLabels <- targets$sample
myDGEList <- DGEList(Txi_gene$counts)
log2.cpm <- cpm(myDGEList, log=TRUE)

log2.cpm.df <- as_tibble(log2.cpm, rownames = "geneID")
colnames(log2.cpm.df) <- c("geneID", sampleLabels)
log2.cpm.df.pivot <- pivot_longer(log2.cpm.df, 
                                  cols = ERR978118:ERR978195,         
                                  names_to = "samples", 
                                  values_to = "expression") 
p1 <- ggplot(log2.cpm.df.pivot) +
  aes(x=samples, y=expression, fill=samples) +
  geom_violin(trim = FALSE, show.legend = FALSE) +
  stat_summary(fun = "median", 
               geom = "point", 
               shape = 95, 
               size = 10, 
               color = "black", 
               show.legend = FALSE) +
  labs(y="log2 expression", x = "Sample",
       title="Log2 Counts per Million (CPM)",
       subtitle="unfiltered, non-normalized",
       caption=paste0("produced on ", Sys.time())) +
  theme_bw()

cpm <- cpm(myDGEList)
keepers <- rowSums(cpm>1)>=nocpm_threshold 
myDGEList.filtered <- myDGEList[keepers,]

log2.cpm.filtered <- cpm(myDGEList.filtered, log=TRUE)
log2.cpm.filtered.df <- as_tibble(log2.cpm.filtered, rownames = "geneID")
colnames(log2.cpm.filtered.df) <- c("geneID", sampleLabels)
log2.cpm.filtered.df.pivot <- pivot_longer(log2.cpm.filtered.df, 
                                           cols = ERR978118:ERR978195, 
                                           names_to = "samples", 
                                           values_to = "expression") 

p2 <- ggplot(log2.cpm.filtered.df.pivot) +
  aes(x=samples, y=expression, fill=samples) +
  geom_violin(trim = FALSE, show.legend = FALSE) +
  stat_summary(fun = "median", 
               geom = "point", 
               shape = 95, 
               size = 10, 
               color = "black", 
               show.legend = FALSE) +
  labs(y="log2 expression", x = "Sample",
       title="Log2 Counts per Million (CPM)",
       subtitle="filtered, non-normalised",
       caption=paste0("produced on ", Sys.time())) +
  theme_bw()

myDGEList.filtered.norm <- calcNormFactors(myDGEList.filtered, method = "TMM")
log2.cpm.filtered.norm <- cpm(myDGEList.filtered.norm, log=TRUE)
log2.cpm.filtered.norm.df <- as_tibble(log2.cpm.filtered.norm, rownames = "geneID")
colnames(log2.cpm.filtered.norm.df) <- c("geneID", sampleLabels)
log2.cpm.filtered.norm.df.pivot <- pivot_longer(log2.cpm.filtered.norm.df, 
                                                cols = ERR978118:ERR978195,
                                                names_to = "samples", 
                                                values_to = "expression") 

p3 <- ggplot(log2.cpm.filtered.norm.df.pivot) +
  aes(x=samples, y=expression, fill=samples) +
  geom_violin(trim = FALSE, show.legend = FALSE) +
  stat_summary(fun = "median", 
               geom = "point", 
               shape = 95, 
               size = 10, 
               color = "black", 
               show.legend = FALSE) +
  labs(y="log2 expression", x = "Sample",
       title="Log2 Counts per Million (CPM)",
       subtitle="filtered, TMM normalised",
       caption=paste0("produced on ", Sys.time())) +
  theme_bw()

#Create the directories for output results
dir.create("report/data", showWarnings = FALSE, recursive = TRUE)
write.csv(log2.cpm.filtered.norm.df, "report/data/log2_cpm_filtered_norm.csv", row.names = F)
write.csv(log2.cpm.filtered.df, "report/data/log2_cpm_filtered.csv", row.names = F)
```

```{r step 1 & 2 filtered out samples}
targets<-targets[!samples_nodepth,]
path <- file.path(targets$sample, "abundance.tsv") # set file paths to your mapped data
Tx <- transcripts(EnsDb.Hsapiens.v86, columns=c("tx_id", "gene_name"))
Tx <- as_tibble(Tx)
Tx <- dplyr::rename(Tx, target_id = tx_id)
Tx <- dplyr::select(Tx, "target_id", "gene_name")
Txi_gene <- tximport(paste0("kallisto/",path), 
                     type = "kallisto", 
                     tx2gene = Tx, 
                     txOut = FALSE, #Transcripts will be collapsed to genes
                     countsFromAbundance = "lengthScaledTPM",
                     ignoreTxVersion = TRUE)

sampleLabels <- targets$sample
myDGEList <- DGEList(Txi_gene$counts)
log2.cpm <- cpm(myDGEList, log=TRUE)

log2.cpm.df <- as_tibble(log2.cpm, rownames = "geneID")
colnames(log2.cpm.df) <- c("geneID", sampleLabels)
log2.cpm.df.pivot <- pivot_longer(log2.cpm.df, 
                                  cols = ERR978118:ERR978195,         
                                  names_to = "samples", 
                                  values_to = "expression") 

cpm <- cpm(myDGEList)
keepers <- rowSums(cpm>1)>=nocpm_threshold 
myDGEList.filtered <- myDGEList[keepers,]

log2.cpm.filtered <- cpm(myDGEList.filtered, log=TRUE)
log2.cpm.filtered.df <- as_tibble(log2.cpm.filtered, rownames = "geneID")
colnames(log2.cpm.filtered.df) <- c("geneID", sampleLabels)
log2.cpm.filtered.df.pivot <- pivot_longer(log2.cpm.filtered.df, 
                                           cols = ERR978118:ERR978195, 
                                           names_to = "samples", 
                                           values_to = "expression") 


myDGEList.filtered.norm <- calcNormFactors(myDGEList.filtered, method = "TMM")
log2.cpm.filtered.norm <- cpm(myDGEList.filtered.norm, log=TRUE)
log2.cpm.filtered.norm.df <- as_tibble(log2.cpm.filtered.norm, rownames = "geneID")
colnames(log2.cpm.filtered.norm.df) <- c("geneID", sampleLabels)
log2.cpm.filtered.norm.df.pivot <- pivot_longer(log2.cpm.filtered.norm.df, 
                                                cols = ERR978118:ERR978195,
                                                names_to = "samples", 
                                                values_to = "expression") 

p4 <- ggplot(log2.cpm.filtered.norm.df.pivot) +
  aes(x=samples, y=expression, fill=samples) +
  geom_violin(trim = FALSE, show.legend = FALSE) +
  stat_summary(fun = "median", 
               geom = "point", 
               shape = 95, 
               size = 10, 
               color = "black", 
               show.legend = FALSE) +
  labs(y="log2 expression", x = "Sample",
       title="Log2 Counts per Million (CPM)",
       subtitle="filtered, TMM normalised, fastQC passed",
       caption=paste0("produced on ", Sys.time())) +
  theme_bw()
pt<-plot_grid(p1, p2, p3, p4,  labels = c('A', 'B', 'C', "D"), label_size = 12, align="hv")

#Create folder for plots
dir.create("report/plots", showWarnings = FALSE, recursive = TRUE)
save_plot("report/plots/log2_cpm_nonfilt_nonnorm.svg",p1, base_width = 15, base_height = 7)
save_plot("report/plots/log2_cpm_nonfilt_nonnorm.png",p1, base_width = 15, base_height = 7)
save_plot("report/plots/log2_cpm_filt_nonnorm.svg",p2, base_width = 15, base_height = 7)
save_plot("report/plots/log2_cpm_filt_nonnorm.png",p2, base_width = 15, base_height = 7)
save_plot("report/plots/log2_cpm_filt_norm.svg",p3, base_width = 15, base_height = 7)
save_plot("report/plots/log2_cpm_filt_norm.png",p3, base_width = 15, base_height = 7)
save_plot("report/plots/log2_cpm_filt_norm_fastqc_ok.svg",p4, base_width = 15, base_height = 7)
save_plot("report/plots/log2_cpm_filt_norm_fastqc_ok.png",p4, base_width = 15, base_height = 7)
save_plot("report/plots/allqualityplots.svg",pt, base_width = 30, base_height = 10)
save_plot("report/plots/allqualityplots.png",pt, base_width = 30, base_height = 10)
```

Filtering was carried out to remove lowly expressed genes. Genes with less than 1 count per million (CPM) in at least `r nocpm_threshold` or more samples were filtered out. This is done to make sure that the low expression is due to a lack of significance across **all** conditions, and not an intrinsic propoerty of one of them. This filtering reduced the number of genes from `r nrow(myDGEList)` to `r nrow(myDGEList.filtered)`. Normalisation of samples was performed with [edgeR](https://bioconductor.org/packages/release/bioc/html/edgeR.html), using *Trimmed Mean of M-value* or *TMM*. This method is based on the assumption that most genes are not differentially expressed. It **calculates a scaling factor for each sample**, which is the median of the ratio of each gene's expression to the geometric mean of all samples. This scaling factor is then used to normalise the expression of each gene in each sample. The normalised expression is then expressed as log2(CPM). The normalisation step is important because it **allows for the comparison of expression between samples**.

According to *fastqc* results, a total of `r sum(samples_nodepth)` samples were removed due to low quality. This is `r round(sum(samples_nodepth)/length(samples_nodepth)*100, 2)`% of the total reads. Filtered out samples are: `r targets$sample[samples_nodepth]`.


------------------------------------------------------------------------

### table of filtered and normalized data

```{r step 3 - multivariate part 1 (data table)}
library(DT)
library(gt)
library(plotly)

mydata.df <- mutate(log2.cpm.filtered.norm.df,
                    adh.AVG = (ERR978118+ERR978120+ERR978121+ERR978107+ERR978112+ERR978116+ERR978117+ERR978119
)/8, 
                    sph.AVG = (ERR978193+ERR978184+ERR978185+ERR978186+ERR978187+ERR978191+ERR978194+ERR978195
)/8,
                    #now make columns comparing each of the averages above that you're interested in
                    LogFC = (sph.AVG - adh.AVG)) %>% #note that this is the first time you've seen the 'pipe' operator
  mutate_if(is.numeric, round, 2)

datatable(mydata.df[,c(1,(ncol(mydata.df)-2):ncol(mydata.df))], 
          extensions = c('KeyTable', "FixedHeader"), 
          filter = 'top',
          options = list(keys = TRUE, 
                         searchHighlight = TRUE, 
                         pageLength = 10, 
                         lengthMenu = c("10", "25", "50", "100")))

```

The table shown below includes expression data for `r nrow(myDGEList.filtered)` genes. You can sort and search the data directly from the table.

------------------------------------------------------------------------

## PCA plot

```{r step 3 - multivariate part 2 (PCA plot)}
media <- targets$media
media <- factor(media)
rep <- targets$replicate
rep <- factor(rep)

pca.res <- prcomp(t(log2.cpm.filtered.norm), scale.=F, retx=T)
pc.var<-pca.res$sdev^2 # sdev^2 captures these eigenvalues from the PCA result
pc.per<-round(pc.var/sum(pc.var)*100, 1) 
pca.res.df <- pca.res$x[,1:4] %>% 
  as_tibble() %>%
  add_column(sample = sampleLabels,
             group = media)

pca.plot_media <- ggplot(pca.res.df) +
  aes(x=PC1, y=PC2, label=sampleLabels, color = media) +
  geom_point(size=4) +
  stat_ellipse() +
  xlab(paste0("PC1 (",pc.per[1],"%",")")) + 
  ylab(paste0("PC2 (",pc.per[2],"%",")")) +
  labs(title="PCA plot coloured by Media",
       caption=paste0("produced on ", Sys.time())) +
  coord_fixed() +
  theme_bw()

pca.plot_replicate <- ggplot(pca.res.df) +
  aes(x=PC1, y=PC2, label=sampleLabels, color = rep) +
  geom_point(size=4) +
  stat_ellipse() +
  xlab(paste0("PC1 (",pc.per[1],"%",")")) + 
  ylab(paste0("PC2 (",pc.per[2],"%",")")) +
  labs(title="PCA plot coloured by replicate",
       caption=paste0("produced on ", Sys.time())) +
  coord_fixed() +
  theme_bw()
# For html ggplotly(pca.plot_media)

  
pca.pivot <- pivot_longer(pca.res.df, 
                          cols = PC1:PC4, 
                          names_to = "PC", 
                          values_to = "loadings") 

small_multiples_plot<-ggplot(pca.pivot) +
  aes(x=sample, y=loadings, fill=sample) + 
  geom_bar(stat="identity") +
  facet_wrap(~PC) +
  labs(title="PCA 'small multiples' plot",
       caption=paste0("produced on ", Sys.time())) +
  theme_bw() +
  theme(legend.position = "none") +
  coord_flip()

all_pca<-plot_grid(pca.plot_media,small_multiples_plot,labels = c('A', 'B'), label_size = 12, align="hv")
save_plot("report/plots/pca.svg",pca.plot_media, base_width = 15, base_height = 7)
save_plot("report/plots/pca.png",pca.plot_media, base_width = 15, base_height = 7)
save_plot("report/plots/pca_sm.svg",small_multiples_plot, base_width = 15, base_height = 7)
save_plot("report/plots/pca_sm.png",small_multiples_plot, base_width = 15, base_height = 7)
save_plot("report/plots/all_pca.svg",all_pca, base_width = 15, base_height = 7)
save_plot("report/plots/all_pca.png",all_pca, base_width = 15, base_height = 7)
all_pca
```

------------------------------------------------------------------------

## Volcano plot

```{r step 5 - diffGenes part 1 (volcano plot)}
library(tidyverse)
library(limma)
library(edgeR) 
library(gt)
library(DT) 
library(plotly) 

design <- model.matrix(~0 + media)
colnames(design) <- levels(media)

v.DEGList.filtered.norm <- voom(myDGEList.filtered.norm, design, plot = FALSE)
fit <- lmFit(v.DEGList.filtered.norm, design)
contrast.matrix <- makeContrasts(treatment = sph - adh,
                                 levels=design)

fits <- contrasts.fit(fit, contrast.matrix)
ebFit <- eBayes(fits)
myTopHits <- topTable(ebFit, adjust ="BH", coef=1, number=40000, sort.by="logFC")

myTopHits.df <- myTopHits %>%
  as_tibble(rownames = "geneID")

vplot <- ggplot(myTopHits.df) +
  aes(y=-log10(adj.P.Val), x=logFC, text = paste("Symbol:", geneID)) +
  geom_point(size=2) +
  geom_hline(yintercept = -log10(0.01), linetype="longdash", colour="grey", size=1) +
  geom_vline(xintercept = 2, linetype="longdash", colour="#BE684D", size=1) +
  geom_vline(xintercept = -2, linetype="longdash", colour="#2C467A", size=1) +
  #annotate("rect", xmin = 1, xmax = 12, ymin = -log10(0.01), ymax = 7.5, alpha=.2, fill="#BE684D") +
  #annotate("rect", xmin = -1, xmax = -12, ymin = -log10(0.01), ymax = 7.5, alpha=.2, fill="#2C467A") +
  labs(title="Volcano plot",
       subtitle = "Cancer Stem Cells enrichment",
       caption=paste0("produced on ", Sys.time())) +
  theme_bw()

ggplotly(vplot)


```

------------------------------------------------------------------------

## Table of DEGs

To identify differentially expressed genes, precision weights were first applied to each gene based on its mean-variance relationship using [VOOM](https://genomebiology.biomedcentral.com/articles/10.1186/gb-2014-15-2-r29), then data was normalized using the [TMM method](https://genomebiology.biomedcentral.com/articles/10.1186/gb-2010-11-3-r25) in [EdgeR](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2796818/). Linear modeling and bayesian stats were employed via [Limma](https://academic.oup.com/nar/article/43/7/e47/2414268) to find genes that were up- or down-regulated in leishmania patients by 4-fold or more, with a false-discovery rate (FDR) of 0.01.

```{r step 5 - diffGenes part 2 (DEG table)}
results <- decideTests(ebFit, method="global", adjust.method="BH", p.value=0.01, lfc=2)
colnames(v.DEGList.filtered.norm$E) <- sampleLabels
diffGenes <- v.DEGList.filtered.norm$E[results[,1] !=0,]
diffGenes.df <- as_tibble(diffGenes, rownames = "geneID")
datatable(diffGenes.df, 
          extensions = c('KeyTable', "FixedHeader"), 
          caption = 'Table 1: DEGs after Cancer Stem Cells Enrichment',
          options = list(keys = TRUE, searchHighlight = TRUE, pageLength = 10, lengthMenu = c("10", "25", "50", "100"))) %>%
  formatRound(columns=c(2:17), digits=2)
```

------------------------------------------------------------------------

## Heatmaps and modules

Pearson correlation was used to cluster **`r nrow(diffGenes)`** differentially expressed genes, which were then represented as heatmap with the data scaled by Zscore for each row.

```{r step 6 - modules part 1 (heatmap)}
library(tidyverse)
library(gplots)
library(RColorBrewer)
myheatcolors <- rev(brewer.pal(name="RdBu", n=11))
clustRows <- hclust(as.dist(1-cor(t(diffGenes), method="pearson")), method="complete") #cluster rows by pearson correlation
clustColumns <- hclust(as.dist(1-cor(diffGenes, method="spearman")), method="complete")
module.assign <- cutree(clustRows, k=2)
module.color <- rainbow(length(unique(module.assign)), start=0.1, end=0.9) 
module.color <- module.color[as.vector(module.assign)] 
heatmap.2(diffGenes, 
          Rowv=as.dendrogram(clustRows), 
          Colv=as.dendrogram(clustColumns),
          RowSideColors=module.color,
          col=myheatcolors, scale='row', labRow=NA,
          density.info="none", trace="none",  
          cexRow=1, cexCol=1, margins=c(8,20))
```

```{r step 6 - modules part 2 (upregulated genes)}
modulePick <- 2 
myModule_up <- diffGenes[names(module.assign[module.assign %in% modulePick]),] 
hrsub_up <- hclust(as.dist(1-cor(t(myModule_up), method="pearson")), method="complete") 

heatmap.2(myModule_up, 
          Rowv=as.dendrogram(hrsub_up), 
          Colv=NA, 
          labRow = NA,
          col=myheatcolors, scale="row", 
          density.info="none", trace="none", 
          RowSideColors=module.color[module.assign%in%modulePick], margins=c(8,20))

```

```{r step 6 - modules part 3 (downregulated genes)}
modulePick <- 1 
myModule_down <- diffGenes[names(module.assign[module.assign %in% modulePick]),] 
hrsub_down <- hclust(as.dist(1-cor(t(myModule_down), method="pearson")), method="complete") 

heatmap.2(myModule_down, 
          Rowv=as.dendrogram(hrsub_down), 
          Colv=NA, 
          labRow = NA,
          col=myheatcolors, scale="row", 
          density.info="none", trace="none", 
          RowSideColors=module.color[module.assign%in%modulePick], margins=c(8,20))
```

## GO enrichment

GO enrichment for the `r nrow(myTopHits)` genes induced by infection

```{r step 7 - functionalEnrichment part 1 (gostplot for upregulated genes)}
library(tidyverse)
library(limma)
library(gplots) #for heatmaps
library(DT) #interactive and searchable tables of our GSEA results
library(GSEABase) #functions and methods for Gene Set Enrichment Analysis
library(Biobase) #base functions for bioconductor; required by GSEABase
library(GSVA) #Gene Set Variation Analysis, a non-parametric and unsupervised method for estimating variation of gene set enrichment across samples.
library(gprofiler2) #tools for accessing the GO enrichment results using g:Profiler web resources
library(clusterProfiler) # provides a suite of tools for functional enrichment analysis
library(msigdbr) # access to msigdb collections directly within R
library(enrichplot) # great for making the standard GSEA enrichment plots
gost.res_up <- gost(rownames(myModule_up), organism = "hsapiens", correction_method = "fdr")
gostplot(gost.res_up, interactive = T, capped = F) #set interactive=FALSE to get plot for publications

```

```{r step 7 - functionalEnrichment part 2 (gostplot for downregulated genes)}
gost.res_down <- gost(rownames(myModule_down), organism = "hsapiens", correction_method = "fdr")
gostplot(gost.res_down, interactive = T, capped = T) #set interactive=FALSE to get plot for publications
```

## GSEA

```{r step 7 - functionalEnrichment part 3 (GSEA table)}
hs_gsea_c2 <- msigdbr(species = "Homo sapiens", # change depending on species your data came from
                      category = "C2") %>% # choose your msigdb collection of interest
  dplyr::select(gs_name, gene_symbol) #just get the columns corresponding to signature name and gene symbols of genes in each signature 

# Now that you have your msigdb collections ready, prepare your data
# grab the dataframe you made in step3 script
# Pull out just the columns corresponding to gene symbols and LogFC for at least one pairwise comparison for the enrichment analysis
mydata.df.sub <- dplyr::select(mydata.df, geneID, LogFC)
mydata.gsea <- mydata.df.sub$LogFC
names(mydata.gsea) <- as.character(mydata.df.sub$geneID)
mydata.gsea <- sort(mydata.gsea, decreasing = TRUE)

# run GSEA using the 'GSEA' function from clusterProfiler
myGSEA.res <- GSEA(mydata.gsea, TERM2GENE=hs_gsea_c2, verbose=FALSE)
myGSEA.df <- as_tibble(myGSEA.res@result)

# view results as an interactive table
datatable(myGSEA.df, 
          extensions = c('KeyTable', "FixedHeader"), 
          caption = 'Signatures enriched after Sphere Media',
          options = list(keys = TRUE, searchHighlight = TRUE, pageLength = 10, lengthMenu = c("10", "25", "50", "100"))) %>%
  formatRound(columns=c(3:10), digits=2)

```

```{r step 7 - functionalEnrichment part 4 (enrich plot)}
# create enrichment plots using the enrichplot package
gseaplot2(myGSEA.res, 
          geneSetID = 136, #can choose multiple signatures to overlay in this plot
          pvalue_table = T, #can set this to FALSE for a cleaner plot
          title = myGSEA.res$Description[136]) #can also turn off this title

```

```{r step 7 - functionalEnrichment part 5 (bubble plot)}
# add a variable to this result that matches enrichment direction with phenotype
myGSEA.df <- myGSEA.df %>%
  mutate(phenotype = case_when(
    NES > 0 ~ "sph",
    NES < 0 ~ "adh"))
abs(myGSEA.df$NES)
top <- sort(abs(myGSEA.df$NES), index.return=TRUE, decreasing=TRUE)
# create 'bubble plot' to summarize y signatures across x phenotypes
ggplot(myGSEA.df[top$ix[1:20],], aes(x=phenotype, y=ID)) + 
  geom_point(aes(size=setSize, color = NES, alpha=-log10(p.adjust))) +
  scale_color_gradient(low="blue", high="red") +
  theme_bw()

```

------------------------------------------------------------------------

## Conclusions


## Session info

The output from running 'sessionInfo' is shown below and details all packages and version necessary to reproduce the results in this report.

```{r session info}
sessionInfo()
```
