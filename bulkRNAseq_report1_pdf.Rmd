---
title: "Report:Transcriptomic effect of Glucose vs Galactose in PDAC"
author: "Andr√©s Gordo Ortiz"
date: "`r Sys.Date()`"
output:
  pdf_document:
    fig_caption: yes
    toc: yes
  html_document:
    code_folding: show
    df_print: paged
    theme: yeti
    highlight: tango
    toc: yes
    toc_float:
      collapsed: false
      smooth_scroll: false
    number_sections: true
---

```{r setup, include=FALSE}
library(rmarkdown)
library(tinytex)
library(readxl)
library(knitr)
library(beepr)
library(tidyverse) 
library(tximport)
library(ensembldb) 
library(EnsDb.Hsapiens.v86)
library(edgeR)
library(matrixStats)
library(cowplot)
library(svglite)
library(DT)
library(gt)
library(plotly)
library(limma)
library(gplots)
library(RColorBrewer) 
library(heatmaply)
library(tidyverse)
library(limma)
library(GSEABase)
library(Biobase)
library(GSVA)
library(gprofiler2)
library(clusterProfiler) 
library(msigdbr) 
library(enrichplot)
library(IsoformSwitchAnalyzeR)
dir.create("report", showWarnings = FALSE, recursive = TRUE)
dir.create("report/data", showWarnings = FALSE, recursive = TRUE)
dir.create("report/plots", showWarnings = FALSE, recursive = TRUE)
dir.create("report/plots/QualityofReads", showWarnings = FALSE, recursive = TRUE)
dir.create("report/plots/multivariate_analysis", showWarnings = FALSE, recursive = TRUE)
dir.create("report/plots/diff_genes", showWarnings = FALSE, recursive = TRUE)
dir.create("report/plots/heatmaps", showWarnings = FALSE, recursive = TRUE)
dir.create("report/plots/FunctionalEnrichment", showWarnings = FALSE, recursive = TRUE)
dir.create("report/plots/FunctionalEnrichment/GSEA", showWarnings = FALSE, recursive = TRUE)
dir.create("report/tables", showWarnings = FALSE, recursive = TRUE)
dir.create("report/IsoformSwitchAnalyzer", showWarnings = FALSE, recursive = TRUE)
knitr::opts_chunk$set(echo=FALSE, warning=FALSE, message=FALSE)
```

```{r settings}
# Change title
# Change and adapt lines 343-348, 355, 417, 459
# Change line 92, data source
# Check the modules are ok on the heatmaps
# Add and change the proper study design, keep it standard

condition1<-"Sphere"
condition_control<-"Adherent"
explanation<- "Cancer Stem Cell enriched genes"
discarded_samples<-c("ERR978114","ERR978122","ERR978189","ERR978196")
nocpm_threshold<-9 #IMPORTANT PARAMETRE: minimum number of samples with CPM > 1

```


## What can I find in this Report?
This analysis performs a fully crafted **Transcriptomics Protocol**, from read mapping, filtering and normalisation, up to Differential Gene Expression, Ontology enrichment or qualitative Isoform usage analysis.This a list of everything you will find within the folders provided.

#### Mapping Folder

1. **Kallisto**: All the output from *Kallisto*, the pseudoaligner of your reads to the reference genome.
2. **FastQC**: Report of the quality and depth of your reads for each sample.
3. **MultiQC**: Summarised report of the quality, depth and alignment success of your reads for every sample, summarized in a single convenient file.

#### Report Folder
##### Data
1. **log2_cpm.csv**: Excel file of the Counts per million of all genes across samples, non filtered, non normalised.

2. **log2_cpm_filtered.csv**: Excel file of the Counts per million of all genes across samples, filtered, non normalised.

3. **log2_cpm_filtered_norm.csv**: Excel file of the Counts per million of all genes across samples, filtered, normalised.

4. **pca_results.csv**: Excel file with the results and loadings of the PCA analysis.

##### IsoformSwitchAnalyzer
1. **common_switch_consequences.pdf**: A handy PDF summarising all isoform switching events in your data.
2. And a Folder with all the plots from Isoform Switch-positive genes.

##### Plots
Every figure is provided in *PNG* (for straightforward digital use) and *SVG* (for high quality printings and figures) formats for convenience.

###### diff_genes
1. **Volcano Plot**: Showing the expression and statistical significance of every gene on the reads.

###### FunctionalEnrichment
1. **Bubble Plot**: Showing the top 20 enriched terms on the *C2* collection.
2. **Manhattan Plot**: Showing the enriched terms on Gene Ontology, from either Up Regulated genes or Down Regulated genes.
3. **GSEA**: Gene Set Enrichment Plots from the top enriched terms on the *C2* collection. 15 of the most upregulated genes, and 15 of the most downregulated genes.

###### Heatmaps
1. **Heatmap_Full**: Heatmap of gene expression across al samples and modules.
2. **Heatmap_Up**: Heatmap of gene expression across all samples but only the module representing the upregulated genes.
3. **Heatmap_Down**: Heatmap of gene expression across all samples but only the module representing the downregulated genes.

###### Multivariate Analysis
1. **PCA**: Principal Component Analysis plot, coloured by the condition to analyse.
2. **PCA SM**: Small Multiples Plot representing the *loadings*, or relevance, of each principal component for every sample. Useful to draw conclusions about possible other variables influencing the variability found.
3. **All PCA**: Figure composed by the two previous plots.
4. **Scatter**: Scatter or dot plot, showing the average expression of each gene between groups.

###### Quality of Reads
1. **log2_cpm_nonfilt_nonnorm**: Counts per million violin plot, without filtering or normalisation.
2. **log2_cpm_filt_nonnorm**: Counts per million violin plot, after filtering but without normalisation.
3. **log2_cpm_filt_norm**: Counts per million violin plot, after filtering and normalisation.
4. **log2_cpm_filt_norm_fastqc_ok**: Definitive counts per million violin plot, after filtering and normalisation, without low quality samples according to fastQC.
5. **allqualityplots**: Figure composed by the previous plots.

##### Tables
1. **differentialexpression_results.csv**: Complete table of the results of the differential expression analysis. All genes mapped to the reference genome with more than 1 count per million are analysed. 
2. **table_1_filtered_normalised.csv**: Table of gene expression in form of counts per million, filtered and normalised. This table can be used for whatever other downstream analysis needed.
3. **table_2_diffGenes.csv**: Table of genes which passed the thresholf of FDR>=0.01 and log-fold change >= 2, in form of counts per million, filtered and normalised.
4. **table3_IsoformSwitchResults.csv**: Table of all Isoform Switches or changes in Usage found between conditions.
5. **`r paste0("table4_module_UpRegulatedIn", condition1,".csv")`**: Table of genes which passed the threshold belonging to to the upregulated module, in form of counts per million. These are the genes upregulated in `r condition1`.
6. **`r paste0("table5_module_downRegulatedIn", condition1,".csv")`**: Table of genes which passed the threshold belonging to to the downregulated module, in form of counts per million. These are the genes downregulated in `r condition1`.
7. **table6_GeneOntology_upRegulated.csv**: Taking the genes from *Table 4* to the *Gene Ontology* database, the following table of enriched pathways and routes was obtained.
8. **table7_GeneOntology_downRegulated.csv**: Taking the genes from *Table 5* to the *Gene Ontology* database, the following table of enriched pathways and routes was obtained.

## Alignment Protocol Used

#### 1. Data Acquisition

- Raw sequencing reads for the project (PRJEB10204) were obtained from the [ENA](https://www.ebi.ac.uk/ena/browser/view/PRJEB10204).

#### 2. Read Mapping

- The obtained raw reads were mapped to the human reference transcriptome [GRCh38.cdna](https://ftp.ensembl.org/pub/release-111/fasta/homo_sapiens/cdna/Homo_sapiens.GRCh38.cdna.all.fa.gz) using [Kallisto](https://pachterlab.github.io/kallisto/) version 0.48.
  - Parameters used for Kallisto:
    - Average length of reads: 250
    - Standard deviation: 30

#### 3. Quality Analysis

- The quality of the mapped reads was assessed using **[fastqc](https://www.bioinformatics.babraham.ac.uk/projects/fastqc/)** and **[multiqc](https://multiqc.info/)**.

#### 4. Experimental Design

- The project includes a total of 20 single-end samples, comprising 10 replicates for each of the two experimental conditions: **with adherent media** and **with sphere media**.


#### 5. Pseudo-alignment and Automated Script

- Pseudo-alignment of the samples to the human reference genome was performed using Kallisto. While a suitable code is provided for the alignment process, a custom, fully automated script [Automatic Kallisto Gene aligner](https://github.com/AndresBioMed/Glu_vs_Gal_PDAC_RNAseq/blob/main/AutomatedKallistoGeneAlignment.sh) was developed *ad hoc* for streamlined analysis. The script requires the input of *.fastqc.gz* files and a cDNA [reference genome](https://www.ensembl.org/info/data/ftp/index.html).


#### 6. Pre-processing

- For each sample, *fastqc* was executed to evaluate the sequencing quality before further analysis. If any samples lacked the quality required to perform downstream analysis that will be noted in its section.


#### 7. Data Integration

- Following read mapping with Kallisto, the [TxImport](https://bioconductor.org/packages/release/bioc/html/tximport.html) package was utilized to import Kallisto outputs into the R environment.

#### 8. Data Summarization

- Annotation data from Biomart was employed to summarize the data from transcript-level to gene-level, providing a comprehensive view of the gene expression landscape.

```{r studydesign, echo=FALSE}
design<-data.frame(sample=c("ERR978118","ERR978120","ERR978121","ERR978193","ERR978107","ERR978112","ERR978114","ERR978184","ERR978185","ERR978186","ERR978187","ERR978191","ERR978194","ERR978116","ERR978117","ERR978119","ERR978122","ERR978189","ERR978195","ERR978196"),
                   condition=c("adh","adh","adh","sph","adh","adh","adh","sph","sph","sph","sph","sph","sph","adh","adh","adh","adh","sph","sph","sph"),
                   replicate=c("b","b","b","b","a","a","a","a","a","a","a","b","b","b","b","b","b","a","b","b"))
#Write design into a .txt file called studydesign
write.table(design, file = "studydesign.txt", sep = "\t", row.names = FALSE)
```

```{r TxImport, echo=FALSE}
targets <- read_tsv("studydesign.txt")
all_samples<-targets$sample
samples_nodepth<-targets$sample %in% discarded_samples # remove samples without enough read depth, according to fastqc.

path <- file.path(targets$sample, "abundance.tsv") # set file paths to your mapped data
Tx <- transcripts(EnsDb.Hsapiens.v86, columns=c("tx_id", "gene_name"))
Tx <- as_tibble(Tx)
Tx <- dplyr::rename(Tx, target_id = tx_id)
Tx <- dplyr::select(Tx, "target_id", "gene_name")
Txi_gene <- tximport(paste0("kallisto/",path), 
                     type = "kallisto", 
                     tx2gene = Tx, 
                     txOut = FALSE, #Transcripts will be collapsed to genes
                     countsFromAbundance = "lengthScaledTPM",
                     ignoreTxVersion = TRUE)
```

------------------------------------------------------------------------

## Preprocessing

### Filtering & normalisation

```{r dataWrangling}
sampleLabels <- targets$sample
myDGEList <- DGEList(Txi_gene$counts)
log2.cpm <- cpm(myDGEList, log=TRUE)

log2.cpm.df <- as_tibble(log2.cpm, rownames = "geneID")
colnames(log2.cpm.df) <- c("geneID", sampleLabels)
log2.cpm.df.pivot <- pivot_longer(log2.cpm.df, 
                                  cols = head(targets$sample, 1):tail(targets$sample, 1),         
                                  names_to = "samples", 
                                  values_to = "expression") 
p1 <- ggplot(log2.cpm.df.pivot) +
  aes(x=samples, y=expression, fill=samples) +
  geom_violin(trim = FALSE, show.legend = FALSE) +
  stat_summary(fun = "median", 
               geom = "point", 
               shape = 95, 
               size = 10, 
               color = "black", 
               show.legend = FALSE) +
  labs(y="log2 expression", x = "Sample",
       title="Log2 Counts per Million (CPM)",
       subtitle="unfiltered, non-normalized",
       caption=paste0("produced on ", Sys.time())) +
  scale_x_discrete(guide = guide_axis(angle = 60))+
  theme_bw()

cpm <- cpm(myDGEList)
keepers <- rowSums(cpm>1)>=nocpm_threshold 
myDGEList.filtered <- myDGEList[keepers,]

log2.cpm.filtered <- cpm(myDGEList.filtered, log=TRUE)
log2.cpm.filtered.df <- as_tibble(log2.cpm.filtered, rownames = "geneID")
colnames(log2.cpm.filtered.df) <- c("geneID", sampleLabels)
log2.cpm.filtered.df.pivot <- pivot_longer(log2.cpm.filtered.df, 
                                           cols = head(targets$sample, 1):tail(targets$sample, 1), 
                                           names_to = "samples", 
                                           values_to = "expression") 

p2 <- ggplot(log2.cpm.filtered.df.pivot) +
  aes(x=samples, y=expression, fill=samples) +
  geom_violin(trim = FALSE, show.legend = FALSE) +
  stat_summary(fun = "median", 
               geom = "point", 
               shape = 95, 
               size = 10, 
               color = "black", 
               show.legend = FALSE) +
  labs(y="log2 expression", x = "Sample",
       title="Log2 Counts per Million (CPM)",
       subtitle="filtered, non-normalised",
       caption=paste0("produced on ", Sys.time())) +
  scale_x_discrete(guide = guide_axis(angle = 60))+
  theme_bw()

myDGEList.filtered.norm <- calcNormFactors(myDGEList.filtered, method = "TMM")
log2.cpm.filtered.norm <- cpm(myDGEList.filtered.norm, log=TRUE)
log2.cpm.filtered.norm.df <- as_tibble(log2.cpm.filtered.norm, rownames = "geneID")
colnames(log2.cpm.filtered.norm.df) <- c("geneID", sampleLabels)
log2.cpm.filtered.norm.df.pivot <- pivot_longer(log2.cpm.filtered.norm.df, 
                                                cols = head(targets$sample, 1):tail(targets$sample, 1),
                                                names_to = "samples", 
                                                values_to = "expression") 

p3 <- ggplot(log2.cpm.filtered.norm.df.pivot) +
  aes(x=samples, y=expression, fill=samples) +
  geom_violin(trim = FALSE, show.legend = FALSE) +
  stat_summary(fun = "median", 
               geom = "point", 
               shape = 95, 
               size = 10, 
               color = "black", 
               show.legend = FALSE) +
  labs(y="log2 expression", x = "Sample",
       title="Log2 Counts per Million (CPM)",
       subtitle="filtered, TMM normalised",
       caption=paste0("produced on ", Sys.time())) +
  scale_x_discrete(guide = guide_axis(angle = 60))+
  theme_bw()

write.csv(log2.cpm.df, "report/data/log2_cpm.csv", row.names = F)
write.csv(log2.cpm.filtered.norm.df, "report/data/log2_cpm_filtered_norm.csv", row.names = F)
write.csv(log2.cpm.filtered.df, "report/data/log2_cpm_filtered.csv", row.names = F)
```

```{r step 1 and 2 -filtered out samples-, fig.cap="Violin plots of log2 CPM values for each sample. A) Raw reads after mapping. B) Genes with more than 9 samples with CPM < 1 were filtered out. C) Normalisation with TMM. D) Tidy Samples with a positive FastQC Result to be used in the downstream analysis"}
targets<-targets[!samples_nodepth,]
path <- file.path(targets$sample, "abundance.tsv") # set file paths to your mapped data
Tx <- transcripts(EnsDb.Hsapiens.v86, columns=c("tx_id", "gene_name"))
Tx <- as_tibble(Tx)
Tx <- dplyr::rename(Tx, target_id = tx_id)
Tx <- dplyr::select(Tx, "target_id", "gene_name")
Txi_gene <- tximport(paste0("kallisto/",path), 
                     type = "kallisto", 
                     tx2gene = Tx, 
                     txOut = FALSE, #Transcripts will be collapsed to genes
                     countsFromAbundance = "lengthScaledTPM",
                     ignoreTxVersion = TRUE)

sampleLabels <- targets$sample
myDGEList <- DGEList(Txi_gene$counts)
log2.cpm <- cpm(myDGEList, log=TRUE)

log2.cpm.df <- as_tibble(log2.cpm, rownames = "geneID")
colnames(log2.cpm.df) <- c("geneID", sampleLabels)
log2.cpm.df.pivot <- pivot_longer(log2.cpm.df, 
                                  cols = head(targets$sample, 1):tail(targets$sample, 1),         
                                  names_to = "samples", 
                                  values_to = "expression") 

cpm <- cpm(myDGEList)
keepers <- rowSums(cpm>1)>=nocpm_threshold 
myDGEList.filtered <- myDGEList[keepers,]

log2.cpm.filtered <- cpm(myDGEList.filtered, log=TRUE)
log2.cpm.filtered.df <- as_tibble(log2.cpm.filtered, rownames = "geneID")
colnames(log2.cpm.filtered.df) <- c("geneID", sampleLabels)
log2.cpm.filtered.df.pivot <- pivot_longer(log2.cpm.filtered.df, 
                                           cols = head(targets$sample, 1):tail(targets$sample, 1), 
                                           names_to = "samples", 
                                           values_to = "expression") 


myDGEList.filtered.norm <- calcNormFactors(myDGEList.filtered, method = "TMM")
log2.cpm.filtered.norm <- cpm(myDGEList.filtered.norm, log=TRUE)
log2.cpm.filtered.norm.df <- as_tibble(log2.cpm.filtered.norm, rownames = "geneID")
colnames(log2.cpm.filtered.norm.df) <- c("geneID", sampleLabels)
log2.cpm.filtered.norm.df.pivot <- pivot_longer(log2.cpm.filtered.norm.df, 
                                                cols = head(targets$sample, 1):tail(targets$sample, 1),
                                                names_to = "samples", 
                                                values_to = "expression") 

p4 <- ggplot(log2.cpm.filtered.norm.df.pivot) +
  aes(x=samples, y=expression, fill=samples) +
  geom_violin(trim = FALSE, show.legend = FALSE) +
  stat_summary(fun = "median", 
               geom = "point", 
               shape = 95, 
               size = 10, 
               color = "black", 
               show.legend = FALSE) +
  labs(y="log2 expression", x = "Sample",
       title="Log2 Counts per Million (CPM)",
       subtitle="filtered, TMM normalised, fastQC passed",
       caption=paste0("produced on ", Sys.time())) +
  scale_x_discrete(guide = guide_axis(angle = 60))+
  theme_bw()
pt<-plot_grid(p1, p2, p3, p4,  labels = c('A', 'B', 'C', "D"), label_size = 12, align="hv")


save_plot("report/plots/QualityofReads/log2_cpm_nonfilt_nonnorm.svg",p1, base_width = 15, base_height = 7)
save_plot("report/plots/QualityofReads/log2_cpm_nonfilt_nonnorm.png",p1, base_width = 15, base_height = 7)
save_plot("report/plots/QualityofReads/log2_cpm_filt_nonnorm.svg",p2, base_width = 15, base_height = 7)
save_plot("report/plots/QualityofReads/log2_cpm_filt_nonnorm.png",p2, base_width = 15, base_height = 7)
save_plot("report/plots/QualityofReads/log2_cpm_filt_norm.svg",p3, base_width = 15, base_height = 7)
save_plot("report/plots/QualityofReads/log2_cpm_filt_norm.png",p3, base_width = 15, base_height = 7)
save_plot("report/plots/QualityofReads/log2_cpm_filt_norm_fastqc_ok.svg",p4, base_width = 15, base_height = 7)
save_plot("report/plots/QualityofReads/log2_cpm_filt_norm_fastqc_ok.png",p4, base_width = 15, base_height = 7)
save_plot("report/plots/QualityofReads/allqualityplots.svg",pt, base_width = 30, base_height = 10)
save_plot("report/plots/QualityofReads/allqualityplots.png",pt, base_width = 30, base_height = 10)

pt
```

Filtering was carried out to remove lowly expressed genes. Genes with less than 1 count per million (CPM) in at least `r nocpm_threshold` or more samples were filtered out. This is done to make sure that the low expression is due to a lack of significance across **all** conditions, and not an intrinsic property of one of them. This filtering reduced the number of genes from `r nrow(myDGEList)` to `r nrow(myDGEList.filtered)`. Normalisation of samples was performed with [edgeR](https://bioconductor.org/packages/release/bioc/html/edgeR.html), using *Trimmed Mean of M-value* or *TMM*. This method is based on the assumption that most genes are not differentially expressed. It **calculates a scaling factor for each sample**, which is the median of the ratio of each gene's expression to the geometric mean of all samples. This scaling factor is then used to normalise the expression of each gene in each sample. The normalised expression is then expressed as log2(CPM). The normalisation step is important because it **allows for the comparison of expression between samples**.

According to *fastQC* results, a total of `r sum(samples_nodepth)` samples were removed due to low quality. This is `r round(sum(samples_nodepth)/length(samples_nodepth)*100, 2)`% of the total reads. Filtered out samples are: `r all_samples[samples_nodepth]`.



------------------------------------------------------------------------

### Filtered and Normalised data

```{r multivariate, fig.cap="Scatter plot showing the divergence in the average expression of every gene between the two conditions"}
mydata.df <- mutate(log2.cpm.filtered.norm.df,
                    adh.AVG = (ERR978118+ERR978120+ERR978121+ERR978107+ERR978112+ERR978116+ERR978117+ERR978119
)/8, 
                    sph.AVG = (ERR978193+ERR978184+ERR978185+ERR978186+ERR978187+ERR978191+ERR978194+ERR978195
)/8,
                    
                    LogFC = (sph.AVG - adh.AVG)) %>% 
  mutate_if(is.numeric, round, 2)
dir.create("report/tables", showWarnings = FALSE, recursive = TRUE)

write.csv(mydata.df, "report/tables/table_1_filtered_normalised.csv", row.names = FALSE)

scatter <- ggplot(mydata.df) + 
  aes(x=adh.AVG, y=sph.AVG, color=abs(LogFC)) +
  geom_point(shape=16, size=1) +
  ggtitle(paste0(condition1," vs. ", condition_control)) +
  theme_bw()
save_plot("report/plots/multivariate_analysis/scatter.svg",scatter, base_width = 7, base_height = 5)
save_plot("report/plots/multivariate_analysis/scatter.png",scatter, base_width = 7, base_height = 5)
# only in html ggplotly(scatter)
scatter
```

```{r datable -only in html, eval=FALSE}
datatable(mydata.df[,c(1,(ncol(mydata.df)-2):ncol(mydata.df))],
          caption = 'Table 1: Filtered and Normalised Genes',
          extensions = c('KeyTable', "FixedHeader"), 
          filter = 'top',
          options = list(keys = TRUE, 
                         searchHighlight = TRUE, 
                         pageLength = 10, 
                         lengthMenu = c("10", "25", "50", "100")))

```

The **Table 1** includes expression data for `r nrow(myDGEList.filtered)` genes. You can sort and search the data directly from the table in the *html* file.

------------------------------------------------------------------------

## PCA plot

```{r  multivariate part 2 (PCA plot), warning=FALSE, message=FALSE, fig.cap="A) Principal Component Analysis plot coloured by condition. The 95% confidence interval is shown if enough samples are analysed. B) Small Multiples Plot showing the loadings, or contribution, of sample gene to the first 4 principal components."}
condition <- targets$condition
condition <- factor(condition)
rep <- targets$replicate
rep <- factor(rep)

pca.res <- prcomp(t(log2.cpm.filtered.norm), scale.=F, retx=T)
pc.var<-pca.res$sdev^2 # sdev^2 captures these eigenvalues from the PCA result
pc.per<-round(pc.var/sum(pc.var)*100, 1) 
pca.res.df <- pca.res$x[,1:4] %>% 
  as_tibble() %>%
  add_column(sample = sampleLabels,
             group = condition)

pca.plot_condition <- ggplot(pca.res.df) +
  aes(x=PC1, y=PC2, label=sampleLabels, color = condition) +
  geom_point(size=4) +
  stat_ellipse() +
  xlab(paste0("PC1 (",pc.per[1],"%",")")) + 
  ylab(paste0("PC2 (",pc.per[2],"%",")")) +
  labs(title="PCA plot coloured by Condition",
       caption=paste0("produced on ", Sys.time())) +
  coord_fixed() +
  theme_bw()



  
pca.pivot <- pivot_longer(pca.res.df, 
                          cols = PC1:PC4, 
                          names_to = "PC", 
                          values_to = "loadings") 

small_multiples_plot<-ggplot(pca.pivot) +
  aes(x=sample, y=loadings, fill=sample) + 
  geom_bar(stat="identity") +
  facet_wrap(~PC) +
  labs(title="PCA 'small multiples' plot",
       caption=paste0("produced on ", Sys.time())) +
  theme_bw() +
  theme(legend.position = "none") +
  coord_flip()

all_pca<-plot_grid(pca.plot_condition,small_multiples_plot,labels = c('A', 'B'), label_size = 12)
save_plot("report/plots/multivariate_analysis/pca.svg",pca.plot_media, base_width = 15, base_height = 7)
save_plot("report/plots/multivariate_analysis/pca.png",pca.plot_media, base_width = 15, base_height = 7)
save_plot("report/plots/multivariate_analysis/pca_sm.svg",small_multiples_plot, base_width = 15, base_height = 7)
save_plot("report/plots/multivariate_analysis/pca_sm.png",small_multiples_plot, base_width = 15, base_height = 7)
save_plot("report/plots/multivariate_analysis/all_pca.svg",all_pca, base_width = 15, base_height = 7)
save_plot("report/plots/multivariate_analysis/all_pca.png",all_pca, base_width = 15, base_height = 7)
write.csv(pca.pivot, "report/data/pca_results.csv", row.names = FALSE)
all_pca
```

------------------------------------------------------------------------

## Volcano plot

An **important** note: all the contrasts, design matrix and differential expression analysis are made according to this formula ***(`r condition1` - `r condition_control`)***. This means that a *logfold change* > 0 shows that the first condition is upregulated, whereas a *logfold change* < 0 shows downregulation.

```{r diffGenes volcano plot, warning=FALSE, fig.cap="Volcano plot of differencial gene expression.The lines delimit the 2 log-fold change and 0.01 adjusted p-value (FDR) thresholds."}
design <- model.matrix(~0 + condition)
colnames(design) <- levels(condition)

v.DEGList.filtered.norm <- voom(myDGEList.filtered.norm, design, plot = FALSE)
fit <- lmFit(v.DEGList.filtered.norm, design)
contrast.matrix <- makeContrasts(treatment = sph - adh,
                                 levels=design)

fits <- contrasts.fit(fit, contrast.matrix)
ebFit <- eBayes(fits)
myTopHits <- topTable(ebFit, adjust ="BH", coef=1, number=40000, sort.by="logFC")

myTopHits.df <- myTopHits %>%
  as_tibble(rownames = "geneID")

write.csv(myTopHits.df, "report/tables/differentialexpression_results.csv", row.names = FALSE)

vplot <- ggplot(myTopHits.df) +
  aes(y=-log10(adj.P.Val), x=logFC, text = paste("Symbol:", geneID)) +
  geom_point(size=2) +
  geom_hline(yintercept = -log10(0.01), linetype="longdash", colour="grey", size=1) +
  geom_vline(xintercept = 2, linetype="longdash", colour="#BE684D", size=1) +
  geom_vline(xintercept = -2, linetype="longdash", colour="#2C467A", size=1) +
  #annotate("rect", xmin = 1, xmax = 12, ymin = -log10(0.01), ymax = 7.5, alpha=.2, fill="#BE684D") +
  #annotate("rect", xmin = -1, xmax = -12, ymin = -log10(0.01), ymax = 7.5, alpha=.2, fill="#2C467A") +
  labs(title="Volcano plot",
       subtitle = explanation,
       caption=paste0("produced on ", Sys.time())) +
  scale_x_continuous(n.breaks = 8)+
  theme_bw()

save_plot("report/plots/diff_genes/volcano.svg",vplot, base_width = 15, base_height = 7)
save_plot("report/plots/diff_genes/volcano.png",vplot, base_width = 15, base_height = 7)
# Only in html ggplotly(vplot)
vplot


```

------------------------------------------------------------------------

## Table of DEGs

To identify differentially expressed genes, precision weights were first applied to each gene based on its mean-variance relationship using [VOOM](https://genomebiology.biomedcentral.com/articles/10.1186/gb-2014-15-2-r29), then data was normalized using the [TMM method](https://genomebiology.biomedcentral.com/articles/10.1186/gb-2010-11-3-r25) in [EdgeR](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2796818/). Linear modeling and bayesian stats were employed via [Limma](https://academic.oup.com/nar/article/43/7/e47/2414268) to find genes that were up- or down-regulated by **2-logfold or more, with a false-discovery rate (FDR) of 0.01**. An interactive table can be found in the *html* version of this report.

```{r step 5 - diffGenes part 2 (DEG table)}
results <- decideTests(ebFit, method="global", adjust.method="BH", p.value=0.01, lfc=2)
colnames(v.DEGList.filtered.norm$E) <- sampleLabels
diffGenes <- v.DEGList.filtered.norm$E[results[,1] !=0,]
diffGenes.df <- as_tibble(diffGenes, rownames = "geneID")

write.csv(diffGenes.df, "report/tables/table_2_diffGenes.csv", row.names = FALSE)
```

```{r table 2 only html, eval=FALSE}
datatable(diffGenes.df, 
          extensions = c('KeyTable', "FixedHeader"), 
          caption = paste0('Table 2: DEGs ', explanation),
          options = list(keys = TRUE, searchHighlight = TRUE, pageLength = 10, lengthMenu = c("10", "25", "50", "100"))) %>%
  formatRound(columns=c(2:ncol(diffGenes.df)), digits=2)
```

------------------------------------------------------------------------

## Isoform Switch Analyzer

Transcript isoforms expression and usage change was analysed through the well-established [IsoformSwitchAnalyzeR](https://bioconductor.org/packages/release/bioc/vignettes/IsoformSwitchAnalyzeR/inst/doc/IsoformSwitchAnalyzeR.html). All differential **expressed/usage** genes will have their own *Switch Plot* and *Switch Table* can be found in the *html* version of this report. Here is the *Switch Plot* of the top 1 gene.
All credits to:
*Soneson et al. Differential analyses for RNA-seq: transcript-level estimates improve gene-level inferences. F1000Research 4, 1521 (2015).*

```{r Isoform Switch Analyzer, message=FALSE, warning=F, results='hide'}
targets.mod <- targets %>%
  dplyr::rename(sampleID = sample, condition = condition) %>%
  dplyr::select(sampleID, condition)

Txi_trans <- importIsoformExpression(sampleVector = paste0("kallisto/",path))
colnames(Txi_trans$abundance) <- c("isoform_id", sampleLabels)
colnames(Txi_trans$counts) <- c("isoform_id", sampleLabels)

# Define file paths
gtf_file_path <- "Homo_sapiens.GRCh38.110.chr_patch_hapl_scaff.gtf.gz"
fa_file_path <- "Homo_sapiens.GRCh38.cdna.all.fa.gz"

# Check if files exist
if (!file.exists(gtf_file_path)) {
  download.file("https://ftp.ensembl.org/pub/release-111/gtf/homo_sapiens/Homo_sapiens.GRCh38.111.chr_patch_hapl_scaff.gtf.gz", gtf_file_path)
}

if (!file.exists(fa_file_path)) {
  download.file("https://ftp.ensembl.org/pub/release-111/fasta/homo_sapiens/cdna/Homo_sapiens.GRCh38.cdna.all.fa.gz", fa_file_path)
}


mySwitchList <- importRdata(
  isoformCountMatrix   = Txi_trans$counts,
  isoformRepExpression = Txi_trans$abundance,
  designMatrix         = targets.mod,
  removeNonConvensionalChr = TRUE,
  addAnnotatedORFs=TRUE,
  fixStringTieAnnotationProblem = TRUE,
  ignoreAfterPeriod=TRUE,
  # the files below must be from the same ensembl release, and must match the reference release version that were originally mapped to the reads.
  isoformExonAnnoation = "Homo_sapiens.GRCh38.110.chr_patch_hapl_scaff.gtf.gz",
  isoformNtFasta       = "Homo_sapiens.GRCh38.cdna.all.fa.gz",
  showProgress = TRUE)

mySwitchList <- isoformSwitchAnalysisCombined(
  switchAnalyzeRlist   = mySwitchList,
  pathToOutput = 'report/IsoformSwitchAnalyzer')

top_switches<-extractTopSwitches(
  mySwitchList,
  filterForConsequences = TRUE, 
  sortByQvals = TRUE)
write.csv(top_switches, "report/tables/table3_IsoformSwitchResults.csv")

```

```{r summary of Isoform Switch, eval=TRUE}
extractSwitchSummary(mySwitchList)

```

```{r table 3 Isoform Switches only html, eval=FALSE}

datatable(top_switches[,-1],
          caption = 'Table 3: Top Isoform Switches',
          extensions = c('KeyTable', "FixedHeader"), 
          filter = 'top',
          options = list(keys = TRUE, 
                         searchHighlight = TRUE, 
                         pageLength = 10, 
                         lengthMenu = c("10", "25", "50", "100")))
```

```{r example switchplot, out.width="80%", fig.cap="Sample of a SwitchPlot. All SwitchPlots generated can be found in their corresponding folder."}
switchPlot(
  mySwitchList,
  gene=top_switches$gene_id[1],
  condition1 = condition_control,
  condition2 = condition1,
  localTheme = theme_bw())
```



```{r IsoformSwitch w/ structure analysis, eval=FALSE}
mySwitchList2 <- importRdata(
  isoformCountMatrix   = Txi_trans$counts,
  isoformRepExpression = Txi_trans$abundance,
  designMatrix         = targets.mod,
  removeNonConvensionalChr = TRUE,
  addAnnotatedORFs=TRUE,
  fixStringTieAnnotationProblem = TRUE,
  ignoreAfterPeriod=TRUE,
  # the files below must be from the same ensembl release, and must match the reference release version that were originally mapped to the reads.
  isoformExonAnnoation = "Homo_sapiens.GRCh38.110.chr_patch_hapl_scaff.gtf.gz",
  isoformNtFasta       = "Homo_sapiens.GRCh38.cdna.all.fa.gz",
  showProgress = TRUE)
dir.create("report/IsoformSwitchAnalyzer")
mySwitchList2 <- isoformSwitchAnalysisPart1(
    switchAnalyzeRlist   = mySwitchList2,
    pathToOutput = 'report/test',
    outputSequences      = TRUE, # change to TRUE when analyzing your own data 
    prepareForWebServers = TRUE  # change to TRUE if you will use webservers for external sequence analysis
)

mySwitchList2<-analyzeCPC2(
    mySwitchList2,
    "report/test/result_cpc2.txt",
    codingCutoff = 0.5,
    removeNoncodinORFs = FALSE,
    quiet=FALSE
)
mySwitchList2<-analyzeSignalP(
    mySwitchList2,
    "report/test/output_protein_type.txt",
    minSignalPeptideProbability = 0.5,
    quiet=FALSE
)
mySwitchList2<-analyzePFAM(
    mySwitchList2,
    "report/test/pfam.txt",
    showProgress=TRUE,
    quiet=FALSE
)
mySwitchList2<-analyzeNetSurfP2(
    mySwitchList2,
    pathToNetSurfP2resultFile,
    smoothingWindowSize = 5,
    probabilityCutoff = 0.5,
    minIdrSize = 30,
    showProgress = TRUE,
    quiet = FALSE
)
mySwitchList2 <- isoformSwitchAnalysisPart2(
  switchAnalyzeRlist        = mySwitchList2, 
  n=15,
  removeNoncodinORFs        = FALSE,
  outputPlots               = TRUE, 
  pathToOutput ="report/test",
  consequencesToAnalyze =   c(
        'coding_potential',
        'ORF_seq_similarity',
        'NMD_status')
)

```

------------------------------------------------------------------------

## Heatmaps and Modules

Pearson correlation was used to cluster **`r nrow(diffGenes)`** differentially expressed genes, which were then represented as heatmap with the data scaled by *Zscore* for each row. On the other hand, Spearman correlation was used to cluster all samples. Two *modules* can be seen, being either up- or down-regulated depending on the condition of the samples.

```{r step 6 - modules part 1 (heatmap), results='hide'}
myheatcolors <- rev(brewer.pal(name="RdBu", n=11))
clustRows <- hclust(as.dist(1-cor(t(diffGenes), method="pearson")), method="complete") 

clustColumns <- hclust(as.dist(1-cor(diffGenes, method="spearman")), method="complete")
module.assign <- cutree(clustRows, k=2) #Important parametre
module.color <- rainbow(length(unique(module.assign)), start=0.1, end=0.9) 
module.color <- module.color[as.vector(module.assign)] 

svg(file = "report/plots/heatmaps/heatmap_full.svg")
heatmap.2(diffGenes, 
          Rowv=as.dendrogram(clustRows), 
          Colv=as.dendrogram(clustColumns),
          RowSideColors=module.color,
          col=myheatcolors, scale='row', labRow=NA,
          density.info="none", trace="none",  
          cexRow=1, cexCol=1, margins=c(7,8))
dev.off()

png(file = "report/plots/heatmaps/heatmap_full.png")
heatmap.2(diffGenes, 
          Rowv=as.dendrogram(clustRows), 
          Colv=as.dendrogram(clustColumns),
          RowSideColors=module.color,
          col=myheatcolors, scale='row', labRow=NA,
          density.info="none", trace="none",  
          cexRow=1, cexCol=1, margins=c(7,8))
dev.off()

```
```{r heatmap full pdf version, fig.cap="Heatmap of all differentially expressed genes, clustered by genes and samples. Scaled by rows to facilitate sample recognition and differentiation", fig.align="center"}
heatmap.2(diffGenes, 
          Rowv=as.dendrogram(clustRows), 
          Colv=as.dendrogram(clustColumns),
          RowSideColors=module.color,
          col=myheatcolors, scale='row', labRow=NA,
          density.info="none", trace="none",  
          cexRow=1, cexCol=1, margins=c(7,8))
```



```{r interactive heatmap full onl html, eval=FALSE}

heatmaply(diffGenes, 
          colors = myheatcolors,
          Rowv=as.dendrogram(clustRows),
          RowSideColors=module.color,
          showticklabels=c(TRUE,FALSE),
          scale='row',
          main ="Heatmap across all samples",)

```

```{r modules part 2 (cluster upregulated in sph), results='hide'}
modulePick <- 1  #Be careful with which is which
myModule_up <- diffGenes[names(module.assign[module.assign %in% modulePick]),] 
hrsub_up <- hclust(as.dist(1-cor(t(myModule_up), method="pearson")), method="complete") 

svg(file = "report/plots/heatmaps/heatmap_upRegulated.svg")
heatmap.2(myModule_up, 
          Rowv=as.dendrogram(hrsub_up), 
          Colv=as.dendrogram(clustColumns), 
          labRow = NA,
          col=myheatcolors, scale="row", 
          density.info="none", trace="none", 
          RowSideColors=module.color[module.assign%in%modulePick], margins=c(8,20))
dev.off()

png(file = "report/plots/heatmaps/heatmap_upRegulated.png")
heatmap.2(myModule_up, 
          Rowv=as.dendrogram(hrsub_up), 
          Colv=as.dendrogram(clustColumns), 
          labRow = NA,
          col=myheatcolors, scale="row", 
          density.info="none", trace="none", 
          RowSideColors=module.color[module.assign%in%modulePick], margins=c(8,20))
dev.off()

moduleSymbols <- tibble(geneID = rev(hrsub_up$labels[hrsub_up$order]))
moduleData <- diffGenes[moduleSymbols$geneID,]
moduleData.df <- as_tibble(moduleData, rownames = "geneSymbol", .name_repair = "unique")
write_csv(moduleData.df,paste0("report/tables/table4_module_upRegulatedIn",condition1,".csv"))
```



```{r interactive heatmap up only html, eval=FALSE}

heatmaply(myModule_up, 
          colors = myheatcolors,
          Rowv=as.dendrogram(hrsub_up), 
          Colv=as.dendrogram(clustColumns),
          RowSideColors=module.color[module.assign%in%modulePick],
          showticklabels=c(TRUE,FALSE),
          scale='row',
          main =paste0("Heatmap of UpRegulated Genes in ", condition1))

```

```{r step 6 - modules part 3 (downregulated genes in sph), results='hide'}
modulePick <- 2 
myModule_down <- diffGenes[names(module.assign[module.assign %in% modulePick]),] 
hrsub_down <- hclust(as.dist(1-cor(t(myModule_down), method="pearson")), method="complete") 

svg(file = "report/plots/heatmaps/heatmap_downRegulated.svg")
heatmap.2(myModule_down, 
          Rowv=as.dendrogram(hrsub_down), 
          Colv=as.dendrogram(clustColumns), 
          labRow = NA,
          col=myheatcolors, scale="row", 
          density.info="none", trace="none", 
          RowSideColors=module.color[module.assign%in%modulePick])
dev.off()

png(file = "report/plots/heatmaps/heatmap_downRegulated.png")
heatmap.2(myModule_down, 
          Rowv=as.dendrogram(hrsub_down), 
          Colv=as.dendrogram(clustColumns), 
          labRow = NA,
          col=myheatcolors, scale="row", 
          density.info="none", trace="none", 
          RowSideColors=module.color[module.assign%in%modulePick])
dev.off()

moduleSymbols <- tibble(geneID = rev(hrsub_down$labels[hrsub_down$order]))
moduleData <- diffGenes[moduleSymbols$geneID,]
moduleData.df <- as_tibble(moduleData, rownames = "geneSymbol", .name_repair = "unique")
write_csv(moduleData.df,paste0("report/tables/table5_module_DownRegulatedIn",condition1,".csv"))
```



```{r interactive heatmap down only html, eval=FALSE}

heatmaply(myModule_down, 
          colors = myheatcolors,
          Rowv=as.dendrogram(hrsub_down), 
          Colv=as.dendrogram(clustColumns),
          RowSideColors=module.color[module.assign%in%modulePick],
          showticklabels=c(TRUE,FALSE),
          scale='row',
          main =paste0("Heatmap of DownRegulated Genes in ", condition1))

```
## GO enrichment

Gene Ontology enrichment for the `r nrow(myTopHits)` genes differentially expressed.


```{r functionalEnrichment part 1 (gostplot for upregulated genes) pdf version, fig.cap="Manhattan plot of GO enrichment for upregulated genes"}
#NOTE: The idea here is to provide 3 results: a simple gostplot with no labels, a gostplot highlighting the top 10 terms, and a table with all the results.
gost.res_up <- gost(rownames(myModule_up), organism = "hsapiens", correction_method = "fdr")
mygostplot_up<-gostplot(gost.res_up, interactive = F, capped = T) #set interactive=FALSE to get plot for publications
mytable_up_sorted<-dplyr::arrange(gost.res_up$result,p_value)%>%
  dplyr::select(term_id,p_value,source,term_name,parents)%>%
  apply(2,as.character)%>%
  as_tibble()
write.csv(mytable_up_sorted, file = "report/tables/table6_GeneOntology_upRegulated.csv")

save_plot("report/plots/FunctionalEnrichment/go_manhattanplotFunctionalEnrichment_Up.svg",mygostplot_up)
save_plot("report/plots/FunctionalEnrichment/go_manhattanplotFunctionalEnrichment_Up.png",mygostplot_up)


mygostplot_up
```

```{r functionalEnrichment part 1 (gostplot top 10 for upregulated genes) pdf version, eval=FALSE}
publish_gostplot(
  mygostplot_up, #your static gostplot from above
  highlight_terms = mytable_up_sorted$term_id[1:10],
  filename = NULL,
  width = NA,
  height = NA)
```

```{r step 7 - functionalEnrichment part 1 (gostplot for upregulated genes) html version, eval=FALSE}
gost.res_up <- gost(rownames(myModule_up), organism = "hsapiens", correction_method = "fdr")
gostplot(gost.res_up, interactive = T, capped = T) #set interactive=FALSE to get plot for publications

```

```{r upregulated table sorted only html, eval=FALSE}
datatable(mytable_up_sorted, 
          extensions = c('KeyTable', "FixedHeader"), 
          caption = paste0('Table 6: Functional Enrichment of Up Regulated genes in ', condition1),
          options = list(keys = TRUE, searchHighlight = TRUE, pageLength = 10, lengthMenu = c("10", "25", "50", "100")))
```


```{r functionalEnrichment part 1 (gostplot for Downregulated genes) pdf version, fig.cap="Manhattan plot of GO enrichment for downregulated genes"}
#NOTE: The idea here is to provide 3 results: a simple gostplot with no labels, a gostplot highlighting the top 10 terms, and a table with all the results.
gost.res_down <- gost(rownames(myModule_down), organism = "hsapiens", correction_method = "fdr")
mygostplot_down<-gostplot(gost.res_down, interactive = F, capped = T) #set interactive=FALSE to get plot for publications
mytable_down_sorted<-dplyr::arrange(gost.res_down$result,p_value)%>%
  dplyr::select(term_id,p_value,source,term_name,parents)%>%
  apply(2,as.character)%>%
  as_tibble()
write.csv(mytable_down_sorted, file = "report/tables/table7_GeneOntology_downRegulated.csv")

save_plot("report/plots/FunctionalEnrichment/manhattanplotFunctionalEnrichment_Down.svg",mygostplot_down)
save_plot("report/plots/FunctionalEnrichment/manhattanplotFunctionalEnrichment_Down.png",mygostplot_down)


mygostplot_down
```
```{r functionalEnrichment part 1 (gostplot top 10 for downregulated genes) pdf version, eval=FALSE}
publish_gostplot(
  mygostplot_down, #your static gostplot from above
  highlight_terms = mytable_down_sorted$term_id[1:10],
  filename = NULL,
  width = NA,
  height = NA)
```

```{r step 7 - functionalEnrichment part 1 (gostplot for downregulated genes) html version, eval=FALSE}
gost.res_down <- gost(rownames(myModule_down), organism = "hsapiens", correction_method = "fdr")
gostplot(gost.res_down, interactive = T, capped = T) #set interactive=FALSE to get plot for publications

```
```{r downregulated table sorted only html, eval=FALSE}
datatable(mytable_down_sorted, 
          extensions = c('KeyTable', "FixedHeader"), 
          caption = paste0('Table 7: Functional Enrichment of Down Regulated genes in ', condition1),
          options = list(keys = TRUE, searchHighlight = TRUE, pageLength = 10, lengthMenu = c("10", "25", "50", "100")))
```

## GSEA
The 34550 gene sets in the Human Molecular Signatures Database **(MSigDB)** are divided into 9 major collections, and several subcollections. In this analysis, we will use the **C2** collection, which contains gene sets that represent canonical pathways, gene ontology, and other gene sets derived from knowledge in the literature. The top 15 genes set for each conditions will have their own *Gene Set Enrichment Plot*. The table will contain all the results for each gene set. A sample plot is shown below.

```{r step 7 - functionalEnrichment part 3 (GSEA table)}
hs_gsea_c2 <- msigdbr(species = "Homo sapiens",
                      category = "C2") %>% #  msigdb collection of interest
  dplyr::select(gs_name, gene_symbol)


# Pull out just the columns corresponding to gene symbols and LogFC for at least one pairwise comparison for the enrichment analysis
mydata.df.sub <- dplyr::select(mydata.df, geneID, LogFC)
mydata.gsea <- mydata.df.sub$LogFC
names(mydata.gsea) <- as.character(mydata.df.sub$geneID)
mydata.gsea <- sort(mydata.gsea, decreasing = TRUE)

# run GSEA using the 'GSEA' function from clusterProfiler
myGSEA.res <- GSEA(mydata.gsea, TERM2GENE=hs_gsea_c2, verbose=FALSE)
myGSEA.df <- as_tibble(myGSEA.res@result)

```


```{r step 7 - functionalEnrichment part 4 (enrich plot), fig.cap="Sample of a Gene Set Enrichment Plot"}
gseaplot2(myGSEA.res, 
          geneSetID = 1, #can choose multiple signatures to overlay in this plot
          pvalue_table = F, #can set this to FALSE for a cleaner plot
          title = myGSEA.res$Description[1]) #can also turn off this title
```

```{r make enrichment plots for both phenotypes, results='hide'}
for (i in 1:15){
  name<-paste0("report/plots/FunctionalEnrichment/GSEA/GSEAplot_",condition1,"Enriched",i,".svg")
  save_plot(name, gseaplot2(myGSEA.res, 
          geneSetID = which(myGSEA.df$NES>0)[i], #can choose multiple signatures to overlay in this plot
          pvalue_table = F, #can set this to FALSE for a cleaner plot
          title = myGSEA.res[myGSEA.df$NES>0,]$Description[i]))
}

for (i in 1:15){
  name<-paste0("report/plots/FunctionalEnrichment/GSEA/GSEAplot_",condition_control,"Enriched",i,".svg")
  save_plot(name, gseaplot2(myGSEA.res, 
          geneSetID = which(myGSEA.df$NES<0)[i], #can choose multiple signatures to overlay in this plot
          pvalue_table = F, #can set this to FALSE for a cleaner plot
          title = myGSEA.res[myGSEA.df$NES<0,]$Description[i]))
}


# add a variable to this result that matches enrichment direction with phenotype

myGSEA.df <- myGSEA.df %>%
  mutate(phenotype = case_when(
    NES > 0 ~ condition1,
    NES < 0 ~ condition_control))
myGSEA.df$NES<-abs(myGSEA.df$NES)
write.csv(myGSEA.df[,-1], file = "report/tables/table8_functionalEnrichment.csv")
```

```{r table of functional enrichment html only, eval=FALSE}
datatable(myGSEA.df, 
          extensions = c('KeyTable', "FixedHeader"), 
          caption = "Table 8: Enrichment plots for both phenotypes",
          options = list(keys = TRUE, searchHighlight = TRUE, pageLength = 10, lengthMenu = c("10", "25", "50", "100")))
```

### Bubble Plot
Finally, a *Bubble Plot* is produced for the top 20 gene sets. The size of the bubble is proportional to the number of genes in the gene set, the color is proportional to the **NES**, and the alpha is proportional to the *-log10(p.adjust)*. The plot is shown below. **NES** means normalized enrichment score, and it is the primary statistic for ranking genes in a GSEA analysis. It represents the degree to which a gene set is overrepresented at the top or bottom of a ranked list of genes. The score is normalized to account for differences in gene set size and in correlations between gene set members and the expression dataset. The **NES** score can be either >0, which means is enriched in the *`r condition1`* condition, or <0, which means it is enriched in the *`r condition_control`* condition. The table provided shows the absolute score beacause it has already been classified in one the two conditions.

```{r functionalEnrichment part 5 (bubble plot), fig.align='left', fig.cap="Bubble plot of the top 20 gene sets within the C2 Collection"}

top <- sort(abs(myGSEA.df$NES), index.return=TRUE, decreasing=TRUE)
# create 'bubble plot' to summarize y signatures across x phenotypes
bubbleplot<-ggplot(myGSEA.df[top$ix[1:20],], aes(x=phenotype, y=ID)) + 
  geom_point(aes(size=setSize, color = NES, alpha=-log10(p.adjust))) +
  scale_color_gradient(low="blue", high="red") +
  theme_bw() +
  theme(legend.position="bottom") +
  labs(x = NULL, y = NULL)

save_plot("report/plots/FunctionalEnrichment/bubbleplotEnichment.svg", bubbleplot)
save_plot("report/plots/FunctionalEnrichment/bubbleplotEnichment.png", bubbleplot)
bubbleplot
```

------------------------------------------------------------------------



## Session info

The output from running 'sessionInfo' is shown below and details all packages and version necessary to reproduce the results in this report.

```{r session info}
sessionInfo()
```

```{r final beep, results='hide'}
beep(3)
